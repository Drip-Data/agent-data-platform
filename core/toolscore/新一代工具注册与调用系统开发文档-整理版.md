# 新一代工具注册与调用系统开发文档

**项目负责人**: 核心研发团队  
**文档版本**: v3.1  
**创建日期**: 2025-01-17  
**更新日期**: 2025-01-17  
**适用场景**: Datapresso Agent 数据炼油厂  

---

## 1. 系统概述

新一代工具注册与调用系统（`core/toolscore`）是一个**纯粹的工具管理平台**，为执行环境中的自主Agent提供工具注册、发现、描述和调用服务。系统专注于管理两大类工具：**Function Tools**（嵌入在runtime中）和**MCP Server**，支持Agent直接查询和选择工具。

### 1.1 核心设计理念

- **职责分离**：工具库专注工具管理，Agent专注智能决策
- **自主决策**：Agent在Runtime中通过prompt直接分析和选择工具
- **纯服务化**：工具库不包含任何业务逻辑或硬编码匹配规则
- **简单实用**：以工具为核心的扁平化管理，避免过度设计
- **动态注册**：支持运行时动态注册新工具

### 1.2 架构原则

1. **Agent智能化**：Agent直接分析需求并选择合适的工具
2. **工具库服务化**：仅提供工具管理和查询API，不做智能推荐
3. **无硬编码规则**：不使用关键词匹配等硬编码逻辑
4. **标准化接口**：统一的工具注册、发现、执行接口
5. **可扩展性**：为将来的分级管理预留扩展空间

---

## 2. 系统架构

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────────────┐
│                   Datapresso Agent Platform                     │
├─────────────────────────────────────────────────────────────────┤
│  🧠 任务生成器        │  🤖 智能执行沙盒     │  📊 评估器           │
│  (轨迹分析)          │  (自主Agent)        │  (效果评估)          │
│                     │                     │                     │
│                     │  ┌─────────────────┐ │                     │
│                     │  │   自主Agent     │ │                     │
│                     │  │ ┌─────────────┐ │ │                     │
│                     │  │ │需求分析引擎 │ │ │                     │
│                     │  │ │工具选择引擎 │ │ │                     │
│                     │  │ │执行策略引擎 │ │ │                     │
│                     │  │ └─────────────┘ │ │                     │
│                     │  └─────────────────┘ │                     │
│                     │         ↕ API调用    │                     │
├─────────────────────────────────────────────────────────────────┤
│                    🛠️ 工具管理库 (纯服务层)                     │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │               UnifiedToolLibrary                          │  │
│  │                  (API Gateway)                           │  │
│  ├─────────────────┬─────────────────┬─────────────────────┤  │
│  │   ToolRegistry   │DescriptionEngine│ UnifiedDispatcher   │  │
│  │  (工具注册中心)   │ (描述生成引擎)   │ (统一调度器)         │  │
│  ├─────────────────┼─────────────────┼─────────────────────┤  │
│  │  FunctionTools  │   MCPServers    │   AdapterLayer      │  │
│  │ (函数工具管理)    │ (MCP服务器管理)  │   (适配器层)        │  │
│  └─────────────────┴─────────────────┴─────────────────────┘  │
│                          ↕                                   │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │              工具管理体系                                  │  │
│  │        Function Tools  +  MCP Servers                   │  │
│  │       (嵌入式工具)      (外部服务)                        │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 工具类型管理

#### 2.2.1 Function Tools
**定义**: 嵌入在Runtime中的Python函数工具

**特点**:
- 直接嵌入在runtime进程中
- 通过Python模块导入和调用
- 支持同步和异步执行
- 资源共享和快速响应

**示例工具**:
```
Function Tools:
├── browser_navigator     # 网页导航器
├── python_executor       # Python代码执行器
├── file_processor        # 文件处理器
├── data_analyzer         # 数据分析器
├── web_scraper          # 网页抓取器
└── api_caller           # API调用器
```

#### 2.2.2 MCP Servers
**定义**: 独立运行的MCP协议服务器

**特点**:
- 独立进程运行
- 通过MCP协议通信
- 支持复杂的外部集成
- 隔离性和可扩展性

**示例服务器**:
```
MCP Servers:
├── database_server      # 数据库操作服务器
├── cloud_api_server     # 云服务API服务器
├── nlp_service_server   # NLP处理服务器
└── workflow_server      # 工作流服务器
```

### 2.3 核心组件

#### 2.3.1 UnifiedToolLibrary (统一工具库)
- **作用**：API网关，为Agent提供统一的查询和调用接口
- **职责**：协调工具注册中心和调度器，提供标准化API
- **不负责**：不进行任何智能推荐或工具匹配

#### 2.3.2 ToolRegistry (工具注册中心)
- **作用**：管理所有工具的注册和元数据
- **核心功能**：
  - Function Tool 注册和管理
  - MCP Server 注册和管理
  - 工具元数据存储和查询
  - 工具状态监控

#### 2.3.3 DescriptionEngine (描述生成引擎)
- **作用**：为Agent提供工具的详细描述信息
- **核心功能**：
  - 生成Agent可理解的工具描述
  - 提供工具使用说明和参数规范
  - 生成使用示例和最佳实践

#### 2.3.4 UnifiedDispatcher (统一调度器)
- **作用**：执行Agent选定的工具调用
- **核心功能**：
  - 工具调用路由和执行
  - Function Tool 和 MCP Server 适配
  - 执行结果标准化

---

## 3. Agent与工具库的交互流程

### 3.1 简化的Agent决策流程

```python
async def agent_autonomous_workflow(user_query: str):
    """Agent自主工作流程 - 简化版"""
    
    # 阶段1: Agent需求分析 (在Runtime中通过prompt)
    tool_requirements = await agent.analyze_tool_requirements(user_query)
    # Agent分析: "这个任务需要什么类型的工具？需要什么功能？"
    
    # 阶段2: 查询工具库获取所有可用工具
    available_tools = await tool_library.get_all_tools()
    
    # 阶段3: Agent选择工具 (通过prompt直接决策)
    selected_tools = await agent.select_tools(
        user_query, tool_requirements, available_tools
    )
    
    # 阶段4: Agent制定执行计划
    execution_plan = await agent.create_execution_plan(
        user_query, selected_tools
    )
    
    # 阶段5: 执行工具调用
    for step in execution_plan:
        result = await tool_library.execute_tool(
            tool_id=step.tool_id,
            action=step.action,
            parameters=step.parameters
        )
        
        # Agent分析结果并决定下一步
        next_action = await agent.analyze_result_and_decide_next(result)
```

### 3.2 带上下文记忆的Agent决策流程

```python
@dataclass
class ExecutionContext:
    """执行上下文，用于维护Agent的记忆"""
    task_description: str
    original_plan: List[Dict]
    executed_steps: List[Dict]
    current_observations: List[str]
    failed_attempts: List[Dict]
    learned_patterns: Dict[str, Any]
    available_tools: List[ToolSpec]

async def agent_workflow_with_memory(user_query: str):
    """带记忆的Agent工作流程"""
    
    # 初始化执行上下文
    context = ExecutionContext(
        task_description=user_query,
        original_plan=[],
        executed_steps=[],
        current_observations=[],
        failed_attempts=[],
        learned_patterns={},
        available_tools=await tool_library.get_all_tools()
    )
    
    # 主执行循环
    max_iterations = 20  # 防止无限循环
    for iteration in range(max_iterations):
        
        # 基于上下文进行决策
        decision = await agent.make_contextual_decision(context)
        
        if decision.action_type == "complete":
            break
        elif decision.action_type == "execute_tool":
            # 执行工具
            result = await tool_library.execute_tool(
                tool_id=decision.tool_id,
                action=decision.action,
                parameters=decision.parameters
            )
            
            # 更新上下文
            await update_execution_context(context, decision, result)
            
        elif decision.action_type == "replan":
            # 基于失败经验重新规划
            context.original_plan = await agent.replan_with_context(context)
            
        elif decision.action_type == "switch_tool":
            # 当前工具不适用，切换到其他工具
            new_tool = await agent.select_alternative_tool(context)
            decision.tool_id = new_tool.tool_id

async def update_execution_context(
    context: ExecutionContext, 
    decision: AgentDecision, 
    result: ExecutionResult
):
    """更新执行上下文"""
    
    # 记录执行步骤
    step_record = {
        "step_id": len(context.executed_steps),
        "tool_id": decision.tool_id,
        "action": decision.action,
        "parameters": decision.parameters,
        "result": result,
        "success": result.success,
        "timestamp": datetime.now().isoformat()
    }
    context.executed_steps.append(step_record)
    
    # 更新观察结果
    if result.output:
        context.current_observations.append(result.output)
        # 保持观察历史在合理范围内
        if len(context.current_observations) > 10:
            context.current_observations = context.current_observations[-10:]
    
    # 记录失败尝试
    if not result.success:
        failure_record = {
            "tool_id": decision.tool_id,
            "action": decision.action,
            "parameters": decision.parameters,
            "error": result.error_message,
            "timestamp": datetime.now().isoformat()
        }
        context.failed_attempts.append(failure_record)
        
        # 学习失败模式
        await learn_from_failure(context, failure_record)

async def learn_from_failure(context: ExecutionContext, failure: Dict):
    """从失败中学习"""
    
    tool_id = failure["tool_id"]
    error_type = failure.get("error", "")
    
    # 记录工具特定的失败模式
    if tool_id not in context.learned_patterns:
        context.learned_patterns[tool_id] = {
            "failed_selectors": [],
            "failed_actions": [],
            "error_patterns": []
        }
    
    # 如果是选择器错误，记录失败的选择器
    if "not found" in error_type.lower() and "selector" in str(failure["parameters"]):
        failed_selector = failure["parameters"].get("selector")
        if failed_selector:
            context.learned_patterns[tool_id]["failed_selectors"].append(failed_selector)
    
    # 记录失败的动作
    context.learned_patterns[tool_id]["failed_actions"].append(failure["action"])
    context.learned_patterns[tool_id]["error_patterns"].append(error_type)
```

### 3.3 改进的Agent Prompt设计

#### 3.3.1 上下文感知的工具选择Prompt

```python
def create_contextual_tool_selection_prompt(context: ExecutionContext) -> str:
    """创建上下文感知的工具选择prompt"""
    
    # 构建失败历史摘要
    failure_summary = ""
    if context.failed_attempts:
        recent_failures = context.failed_attempts[-3:]  # 最近3次失败
        failure_summary = "最近的失败尝试:\n"
        for i, failure in enumerate(recent_failures, 1):
            failure_summary += f"{i}. 工具: {failure['tool_id']}, 错误: {failure['error']}\n"
    
    # 构建观察历史
    observation_summary = ""
    if context.current_observations:
        recent_obs = context.current_observations[-2:]  # 最近2个观察
        observation_summary = "当前观察:\n" + "\n".join(recent_obs)
    
    # 构建学习模式
    learned_patterns_summary = ""
    if context.learned_patterns:
        learned_patterns_summary = "已知问题模式:\n"
        for tool_id, patterns in context.learned_patterns.items():
            if patterns["failed_selectors"]:
                learned_patterns_summary += f"- {tool_id}: 避免使用选择器 {patterns['failed_selectors']}\n"
    
    return f"""
你是一个智能工具选择专家。请基于上下文信息分析用户任务并选择最合适的工具：

原始任务: {context.task_description}

{failure_summary}

{observation_summary}

{learned_patterns_summary}

已执行步骤数: {len(context.executed_steps)}

可用工具:
{format_tools_for_prompt(context.available_tools)}

请分析:
1. 基于失败历史，哪些方法已经证明不可行？
2. 当前观察结果表明任务进展如何？
3. 下一步应该选择什么工具和策略？
4. 如何避免重复之前的错误？

输出格式:
ACTION_TYPE: [execute_tool|replan|switch_tool|complete]
SELECTED_TOOL: [工具ID]
ACTION: [具体动作]
PARAMETERS: [参数]
REASONING: [基于上下文的选择理由]
"""

def create_adaptive_execution_prompt(context: ExecutionContext, tool_id: str) -> str:
    """创建自适应执行prompt"""
    
    tool_failures = context.learned_patterns.get(tool_id, {})
    
    return f"""
你正在使用工具 {tool_id} 执行任务的一部分。

任务: {context.task_description}
当前步骤: {len(context.executed_steps) + 1}

该工具的已知问题:
- 失败的选择器: {tool_failures.get('failed_selectors', [])}
- 失败的动作: {tool_failures.get('failed_actions', [])}

最近的观察:
{context.current_observations[-1] if context.current_observations else '无'}

请制定执行策略:
1. 避免使用已知失败的方法
2. 基于当前观察调整参数
3. 考虑备用方案

输出具体的执行参数。
"""
```

---

## 4. 数据模型设计

### 4.1 工具类型定义

```python
class ToolType(Enum):
    FUNCTION = "function"      # 嵌入式Python函数工具
    MCP_SERVER = "mcp_server"  # MCP服务器工具
```

### 4.2 工具能力模型

```python
@dataclass
class ToolCapability:
    name: str                           # 能力名称
    description: str                    # 能力描述
    parameters: Dict[str, Any]          # 参数规范
    examples: List[Dict[str, Any]]      # 使用示例
    category: str = "general"           # 能力类别（为将来分类预留）
```

### 4.3 工具规范模型

```python
@dataclass
class ToolSpec:
    tool_id: str                        # 工具唯一标识
    name: str                          # 工具名称
    description: str                   # 工具描述
    tool_type: ToolType                # 工具类型
    capabilities: List[ToolCapability] # 工具能力列表
    tags: List[str] = field(default_factory=list)  # 标签（为将来分类预留）
    version: str = "1.0.0"
    enabled: bool = True
    metadata: Dict[str, Any] = field(default_factory=dict)
```

### 4.4 Function Tool规范

```python
@dataclass
class FunctionToolSpec(ToolSpec):
    module_path: str = ""               # Python模块路径
    class_name: str = ""                # 类名
    init_params: Dict[str, Any] = field(default_factory=dict)  # 初始化参数
```

### 4.5 MCP Server规范

```python
@dataclass
class MCPServerSpec(ToolSpec):
    server_config: Dict[str, Any] = field(default_factory=dict)   # 服务器配置
    endpoint: str = ""                      # 服务端点
    connection_params: Dict[str, Any] = field(default_factory=dict)  # 连接参数
```

---

## 5. API设计

### 5.1 工具查询API

```python
class UnifiedToolLibrary:
    # 工具查询API
    async def get_all_tools(self) -> List[ToolSpec]:
        """获取所有可用工具"""
        
    async def get_tools_by_type(self, tool_type: ToolType) -> List[ToolSpec]:
        """按类型获取工具"""
        
    async def get_tool_by_id(self, tool_id: str) -> Optional[ToolSpec]:
        """获取指定工具"""
        
    async def search_tools_by_tags(self, tags: List[str]) -> List[ToolSpec]:
        """按标签搜索工具（为将来扩展预留）"""
```

### 5.2 工具注册API

```python
class UnifiedToolLibrary:
    # 工具注册API
    async def register_function_tool(self, tool_spec: FunctionToolSpec) -> RegistrationResult:
        """注册Function Tool"""
        
    async def register_mcp_server(self, server_spec: MCPServerSpec) -> RegistrationResult:
        """注册MCP Server"""
        
    async def unregister_tool(self, tool_id: str) -> bool:
        """注销工具"""
```

### 5.3 工具描述API

```python
class UnifiedToolLibrary:
    # 描述API
    async def get_tool_description_for_agent(self, tool_id: str) -> str:
        """获取Agent可理解的工具描述"""
        
    async def get_all_tools_description_for_agent(self) -> str:
        """获取所有工具的Agent可理解描述"""
        
    async def get_tool_usage_examples(self, tool_id: str) -> List[Dict[str, Any]]:
        """获取工具使用示例"""
```

### 5.4 工具执行API

```python
class UnifiedToolLibrary:
    # 执行API
    async def execute_tool(self, tool_id: str, action: str, parameters: Dict[str, Any]) -> ExecutionResult:
        """执行单个工具"""
        
    async def batch_execute_tools(self, tool_calls: List[Dict[str, Any]]) -> List[ExecutionResult]:
        """批量执行工具"""
        
    async def get_tool_health_status(self, tool_id: str) -> Dict[str, Any]:
        """获取工具健康状态"""
```

### 5.5 上下文感知API

```python
class UnifiedToolLibrary:
    # 上下文感知API
    async def execute_tool_with_context(
        self, 
        tool_id: str, 
        action: str, 
        parameters: Dict[str, Any],
        execution_context: Optional[ExecutionContext] = None
    ) -> ExecutionResult:
        """带上下文的工具执行"""
        
        # 基于上下文调整执行策略
        if execution_context:
            parameters = await self._adjust_parameters_based_on_context(
                tool_id, action, parameters, execution_context
            )
        
        result = await self.execute_tool(tool_id, action, parameters)
        
        # 更新工具特定的学习模式
        if execution_context and not result.success:
            await self._record_tool_failure_pattern(tool_id, action, parameters, result)
        
        return result
    
    async def get_alternative_tools(
        self, 
        failed_tool_id: str, 
        task_context: str,
        execution_context: ExecutionContext
    ) -> List[ToolSpec]:
        """获取替代工具建议"""
        
        # 基于失败工具的类型和任务上下文推荐替代方案
        all_tools = await self.get_all_tools()
        
        # 过滤掉已经失败的工具
        failed_tools = {attempt["tool_id"] for attempt in execution_context.failed_attempts}
        
        alternative_tools = [
            tool for tool in all_tools 
            if tool.tool_id not in failed_tools
            and await self._is_tool_suitable_for_context(tool, task_context)
        ]
        
        return alternative_tools
    
    async def suggest_parameter_adjustments(
        self,
        tool_id: str,
        action: str,
        failed_parameters: Dict[str, Any],
        error_message: str
    ) -> Dict[str, Any]:
        """基于失败原因建议参数调整"""
        
        tool_spec = await self.get_tool_by_id(tool_id)
        if not tool_spec:
            return failed_parameters
        
        # 分析错误类型并建议调整
        if "not found" in error_message.lower():
            # 选择器错误，建议更通用的选择器
            if "selector" in failed_parameters:
                return await self._suggest_alternative_selectors(
                    failed_parameters["selector"], tool_spec
                )
        
        elif "timeout" in error_message.lower():
            # 超时错误，建议增加等待时间
            if "timeout" in failed_parameters:
                failed_parameters["timeout"] = min(
                    failed_parameters.get("timeout", 10) * 2, 60
                )
        
        return failed_parameters
    
    async def get_tool_failure_patterns(self, tool_id: str) -> Dict[str, List]:
        """获取工具的失败模式统计"""
        
        # 从执行历史中统计该工具的失败模式
        return await self.analytics_service.get_tool_failure_patterns(tool_id)
    
    async def _adjust_parameters_based_on_context(
        self,
        tool_id: str,
        action: str,
        parameters: Dict[str, Any],
        context: ExecutionContext
    ) -> Dict[str, Any]:
        """基于上下文调整参数"""
        
        # 检查是否有该工具的失败模式
        if tool_id in context.learned_patterns:
            patterns = context.learned_patterns[tool_id]
            
            # 避免使用失败的选择器
            if "selector" in parameters:
                current_selector = parameters["selector"]
                if current_selector in patterns.get("failed_selectors", []):
                    # 尝试使用更通用的选择器
                    alternative_selector = await self._get_alternative_selector(
                        current_selector, context.current_observations
                    )
                    if alternative_selector:
                        parameters["selector"] = alternative_selector
            
            # 基于错误模式调整其他参数
            if "timeout" in parameters and "timeout" in str(patterns.get("error_patterns", [])):
                parameters["timeout"] = min(parameters.get("timeout", 10) * 2, 60)
        
        return parameters
    
    async def _record_tool_failure_pattern(
        self,
        tool_id: str,
        action: str,
        parameters: Dict[str, Any],
        result: ExecutionResult
    ):
        """记录工具失败模式到持久化存储"""
        
        failure_record = {
            "tool_id": tool_id,
            "action": action,
            "parameters": parameters,
            "error_message": result.error_message,
            "error_type": result.error_type,
            "timestamp": datetime.now().isoformat()
        }
        
        await self.analytics_service.record_failure_pattern(failure_record)
```

---

## 6. 使用指南

### 6.1 系统初始化

```python
from core.toolscore import UnifiedToolLibrary

# 创建工具库实例
tool_library = UnifiedToolLibrary()

# 初始化
await tool_library.initialize()
```

### 6.2 注册Function Tool

```python
from core.toolscore import FunctionToolSpec, ToolCapability, ToolType

# 定义工具能力
capabilities = [
    ToolCapability(
        name="navigate",
        description="导航到指定网页",
        parameters={
            "url": {"type": "string", "description": "目标网页URL", "required": True}
        },
        examples=[{"url": "https://www.example.com"}],
        category="web"
    ),
    ToolCapability(
        name="click",
        description="点击页面元素",
        parameters={
            "selector": {"type": "string", "description": "CSS选择器", "required": True}
        },
        examples=[{"selector": "#submit-button"}],
        category="web"
    )
]

# 创建工具规范
browser_tool = FunctionToolSpec(
    tool_id="browser_navigator",
    name="网页导航器",
    description="提供网页导航和元素交互功能",
    tool_type=ToolType.FUNCTION,
    capabilities=capabilities,
    tags=["web", "automation", "browser"],  # 为将来分类预留
    module_path="tools.browser.navigator",
    class_name="BrowserNavigator"
)

# 注册工具
result = await tool_library.register_function_tool(browser_tool)
```

### 6.3 注册MCP Server

```python
from core.toolscore import MCPServerSpec, ToolCapability, ToolType

# 定义MCP服务器能力
capabilities = [
    ToolCapability(
        name="query",
        description="执行数据库查询",
        parameters={
            "sql": {"type": "string", "description": "SQL查询语句", "required": True},
            "database": {"type": "string", "description": "数据库名称", "required": False}
        },
        examples=[{"sql": "SELECT * FROM users", "database": "main"}],
        category="database"
    )
]

# 创建MCP服务器规范
db_server = MCPServerSpec(
    tool_id="database_server",
    name="数据库服务器",
    description="提供数据库查询和操作功能",
    tool_type=ToolType.MCP_SERVER,
    capabilities=capabilities,
    tags=["database", "sql", "query"],
    endpoint="ws://localhost:8080/mcp",
    connection_params={"timeout": 30, "retry_count": 3}
)

# 注册MCP服务器
result = await tool_library.register_mcp_server(db_server)
```

### 6.4 Agent查询和使用工具

```python
async def agent_workflow(user_query: str):
    """Agent在Runtime中的工作流程"""
    
    # 1. 获取所有可用工具
    all_tools = await tool_library.get_all_tools()
    
    # 2. 获取工具的Agent友好描述
    tools_description = await tool_library.get_all_tools_description_for_agent()
    
    # 3. Agent通过prompt分析并选择工具
    selected_tools = await agent_model.select_tools(user_query, tools_description)
    
    # 4. Agent制定执行计划
    execution_plan = await agent_model.create_execution_plan(user_query, selected_tools)
    
    # 5. 执行计划
    results = []
    for step in execution_plan:
        result = await tool_library.execute_tool(
            tool_id=step.tool_id,
            action=step.action,
            parameters=step.parameters
        )
        results.append(result)
        
        # Agent分析结果并决定是否继续
        should_continue = await agent_model.analyze_result(result)
        if not should_continue:
            break
    
    return results
```

---

## 7. 描述引擎设计

### 7.1 Agent友好的工具描述

```python
class DescriptionEngine:
    async def generate_tool_description_for_agent(self, tool_id: str) -> str:
        """为Agent生成工具描述"""
        tool_spec = await self.tool_registry.get_tool(tool_id)
        
        capabilities_desc = "\n".join([
            f"  - {cap.name}: {cap.description}"
            f"\n    参数: {self._format_parameters(cap.parameters)}"
            f"\n    示例: {cap.examples[0] if cap.examples else 'N/A'}"
            for cap in tool_spec.capabilities
        ])
        
        return f"""
工具: {tool_spec.name} (ID: {tool_spec.tool_id})
类型: {tool_spec.tool_type.value}
描述: {tool_spec.description}
标签: {', '.join(tool_spec.tags)}

可用功能:
{capabilities_desc}

使用场景: 当需要{tool_spec.description.lower()}时使用此工具
"""
    
    async def generate_all_tools_description_for_agent(self) -> str:
        """为Agent生成所有工具的描述"""
        all_tools = await self.tool_registry.get_all_tools()
        
        descriptions = []
        for tool in all_tools:
            desc = await self.generate_tool_description_for_agent(tool.tool_id)
            descriptions.append(desc)
        
        return "\n" + "="*80 + "\n".join(descriptions)
```

---

## 8. Runtime集成

### 8.1 在Runtime中使用工具库

```python
class ReasoningRuntime:
    def __init__(self):
        self.tool_library = UnifiedToolLibrary()
        self.agent_model = None  # LLM模型用于Agent决策
        
    async def initialize(self):
        await self.tool_library.initialize()
        
        # 注册内置工具
        await self.register_builtin_tools()
    
    async def register_builtin_tools(self):
        """注册内置工具"""
        # 注册浏览器工具
        await self.register_browser_tool()
        
        # 注册Python执行工具
        await self.register_python_executor()
        
        # 注册文件处理工具
        await self.register_file_processor()
    
    async def execute_user_query(self, user_query: str):
        """执行用户查询"""
        
        # Agent自主选择和执行工具
        tools_description = await self.tool_library.get_all_tools_description_for_agent()
        
        # Agent分析任务并选择工具
        execution_plan = await self.agent_analyze_and_plan(user_query, tools_description)
        
        # 执行计划
        results = []
        for step in execution_plan:
            result = await self.tool_library.execute_tool(
                step["tool_id"], step["action"], step["parameters"]
            )
            results.append(result)
            
            # Agent分析结果并决定下一步
            should_continue = await self.agent_analyze_result(result)
            if not should_continue:
                break
        
        return results
    
    async def agent_analyze_and_plan(self, query: str, tools_desc: str) -> List[Dict]:
        """Agent分析任务并制定执行计划"""
        prompt = f"""
        任务: {query}
        
        可用工具:
        {tools_desc}
        
        请分析任务需求，选择合适的工具，并制定执行计划。
        输出JSON格式的执行步骤列表。
        """
        
        response = await self.agent_model.generate(prompt)
        return self.parse_execution_plan(response)
```

### 8.2 上下文感知的Runtime实现

```python
class ContextAwareReasoningRuntime(ReasoningRuntime):
    """支持上下文感知的推理Runtime"""
    
    def __init__(self):
        super().__init__()
        self.max_retries = 3  # 最大重试次数
        self.max_iterations = 20  # 最大迭代次数
    
    async def execute_user_query_with_context(self, user_query: str):
        """带上下文感知的用户查询执行"""
        
        # 初始化执行上下文
        context = ExecutionContext(
            task_description=user_query,
            original_plan=[],
            executed_steps=[],
            current_observations=[],
            failed_attempts=[],
            learned_patterns={},
            available_tools=await self.tool_library.get_all_tools()
        )
        
        # 主执行循环
        for iteration in range(self.max_iterations):
            try:
                # 基于上下文做决策
                decision = await self.make_contextual_decision(context)
                
                if decision["action_type"] == "complete":
                    break
                    
                elif decision["action_type"] == "execute_tool":
                    # 使用上下文感知的工具执行
                    result = await self.tool_library.execute_tool_with_context(
                        tool_id=decision["tool_id"],
                        action=decision["action"],
                        parameters=decision["parameters"],
                        execution_context=context
                    )
                    
                    # 更新上下文
                    await self.update_execution_context(context, decision, result)
                    
                    # 检查是否需要重试或切换策略
                    if not result.success:
                        await self.handle_execution_failure(context, decision, result)
                    
                elif decision["action_type"] == "replan":
                    # 重新规划
                    await self.replan_with_context(context)
                    
                elif decision["action_type"] == "switch_tool":
                    # 切换到替代工具
                    await self.switch_to_alternative_tool(context, decision)
                    
            except Exception as e:
                await self.handle_unexpected_error(context, e)
                
        return self.generate_final_result(context)
    
    async def make_contextual_decision(self, context: ExecutionContext) -> Dict[str, Any]:
        """基于上下文做决策"""
        
        # 检查是否应该停止（成功完成或达到最大尝试次数）
        if await self.should_complete_task(context):
            return {"action_type": "complete"}
        
        # 检查是否需要重新规划
        if await self.should_replan(context):
            return {"action_type": "replan"}
        
        # 构建上下文感知的prompt
        prompt = self.create_contextual_decision_prompt(context)
        
        # Agent决策
        response = await self.agent_model.generate(prompt)
        decision = self.parse_agent_decision(response)
        
        # 验证决策的合理性
        validated_decision = await self.validate_decision(decision, context)
        
        return validated_decision
    
    async def handle_execution_failure(
        self, 
        context: ExecutionContext, 
        decision: Dict[str, Any], 
        result: ExecutionResult
    ):
        """处理执行失败"""
        
        tool_id = decision["tool_id"]
        
        # 统计该工具的失败次数
        tool_failures = [
            attempt for attempt in context.failed_attempts 
            if attempt["tool_id"] == tool_id
        ]
        
        if len(tool_failures) >= self.max_retries:
            # 该工具失败次数过多，建议切换工具
            await self.suggest_tool_switch(context, tool_id)
        else:
            # 尝试参数调整
            adjusted_params = await self.tool_library.suggest_parameter_adjustments(
                tool_id=tool_id,
                action=decision["action"],
                failed_parameters=decision["parameters"],
                error_message=result.error_message
            )
            
            # 如果参数有调整，记录建议
            if adjusted_params != decision["parameters"]:
                context.learned_patterns.setdefault(tool_id, {}).setdefault(
                    "suggested_adjustments", []
                ).append({
                    "original_params": decision["parameters"],
                    "adjusted_params": adjusted_params,
                    "reason": result.error_message
                })
    
    async def suggest_tool_switch(self, context: ExecutionContext, failed_tool_id: str):
        """建议切换工具"""
        
        # 获取替代工具
        alternative_tools = await self.tool_library.get_alternative_tools(
            failed_tool_id=failed_tool_id,
            task_context=context.task_description,
            execution_context=context
        )
        
        if alternative_tools:
            # 记录工具切换建议
            context.learned_patterns.setdefault("tool_switches", []).append({
                "from_tool": failed_tool_id,
                "to_tools": [tool.tool_id for tool in alternative_tools],
                "reason": f"Tool {failed_tool_id} failed {self.max_retries} times"
            })
    
    def create_contextual_decision_prompt(self, context: ExecutionContext) -> str:
        """创建上下文感知的决策prompt"""
        
        # 分析当前状态
        status_summary = self.analyze_execution_status(context)
        
        # 构建失败历史
        failure_summary = self.build_failure_summary(context)
        
        # 构建学习建议
        learning_summary = self.build_learning_summary(context)
        
        return f"""
你是一个智能任务执行专家。请基于以下上下文信息决定下一步行动：

任务: {context.task_description}

执行状态: {status_summary}

{failure_summary}

{learning_summary}

可用工具: {len(context.available_tools)}个

请决定下一步行动:
1. execute_tool: 执行特定工具
2. replan: 重新规划整个任务
3. switch_tool: 切换到其他工具
4. complete: 任务完成

重要原则:
- 不要重复已经失败多次的相同操作
- 基于失败经验调整策略
- 考虑使用替代工具或方法
- 如果无法取得进展，及时重新规划

输出JSON格式:
{{
    "action_type": "execute_tool|replan|switch_tool|complete",
    "tool_id": "如果是execute_tool，指定工具ID",
    "action": "如果是execute_tool，指定动作",
    "parameters": "如果是execute_tool，指定参数",
    "reasoning": "决策理由"
}}
"""
    
    def analyze_execution_status(self, context: ExecutionContext) -> str:
        """分析执行状态"""
        
        total_steps = len(context.executed_steps)
        successful_steps = len([step for step in context.executed_steps if step["success"]])
        failed_steps = len(context.failed_attempts)
        
        return f"总步骤: {total_steps}, 成功: {successful_steps}, 失败: {failed_steps}"
    
    def build_failure_summary(self, context: ExecutionContext) -> str:
        """构建失败摘要"""
        
        if not context.failed_attempts:
            return ""
        
        # 按工具分组失败次数
        tool_failures = {}
        for failure in context.failed_attempts:
            tool_id = failure["tool_id"]
            tool_failures[tool_id] = tool_failures.get(tool_id, 0) + 1
        
        failure_lines = []
        for tool_id, count in tool_failures.items():
            failure_lines.append(f"- {tool_id}: {count}次失败")
        
        return "失败历史:\n" + "\n".join(failure_lines)
    
    def build_learning_summary(self, context: ExecutionContext) -> str:
        """构建学习摘要"""
        
        if not context.learned_patterns:
            return ""
        
        learning_lines = []
        for tool_id, patterns in context.learned_patterns.items():
            if patterns.get("failed_selectors"):
                learning_lines.append(
                    f"- {tool_id}: 避免选择器 {patterns['failed_selectors']}"
                )
            if patterns.get("suggested_adjustments"):
                learning_lines.append(
                    f"- {tool_id}: 有参数调整建议"
                )
        
        return "学习到的模式:\n" + "\n".join(learning_lines) if learning_lines else ""
```

---

## 9. 扩展和分级管理

### 9.1 为将来的分级管理预留扩展

```python
# 当工具数量增多时，可以引入分类管理
class ToolCategory:
    """工具分类（将来扩展时使用）"""
    WEB_AUTOMATION = "web_automation"
    DATA_PROCESSING = "data_processing"
    CODE_EXECUTION = "code_execution"
    FILE_MANAGEMENT = "file_management"
    
# 扩展工具规范以支持分类
@dataclass
class ExtendedToolSpec(ToolSpec):
    category: str = "general"           # 工具分类
    subcategory: str = "general"        # 子分类
    priority: int = 1                   # 优先级
    dependencies: List[str] = field(default_factory=list)  # 依赖的其他工具
```

### 9.2 标签系统

```python
# 使用标签系统支持灵活的工具组织
async def search_tools_by_requirements(self, requirements: List[str]) -> List[ToolSpec]:
    """根据需求搜索工具"""
    # 可以根据标签、描述、能力等进行模糊匹配
    # 为Agent提供更精准的工具推荐
```

---

## 10. 迁移和兼容性

### 10.1 从现有系统平滑迁移

1. **保持现有工具接口**：现有工具实现无需修改
2. **逐步注册到新系统**：将现有工具按新的规范注册
3. **Agent逐步接管决策**：从硬编码匹配转为Agent自主选择
4. **保留扩展空间**：为将来的分级管理留下接口

### 10.2 分阶段实施

```python
# 阶段1: 基础工具注册
await tool_library.register_function_tool(browser_tool)
await tool_library.register_function_tool(python_tool)

# 阶段2: Agent集成
runtime.agent_model = LLMModel()
await runtime.enable_agent_decision_making()

# 阶段3: 移除硬编码逻辑
await runtime.disable_hardcoded_matching()

# 阶段4: 引入分级管理（当工具数量增多时）
await tool_library.enable_category_management()
```

---

## 11. 总结

简化后的工具注册与调用系统实现了**直接高效的工具管理**，并重点解决了**Agent重复调用和缺乏上下文延续**的关键问题：

### 11.1 工具库职责
- ✅ **纯粹的工具管理**：注册、存储、查询Function Tools和MCP Servers
- ✅ **标准化服务**：提供统一的API接口
- ✅ **扁平化组织**：直接以工具为核心的管理方式
- ✅ **上下文感知执行**：基于执行历史调整工具参数和策略
- ❌ **不负责决策**：不进行任何智能推荐或匹配

### 11.2 Agent职责
- ✅ **直接需求分析**：通过prompt理解用户需求
- ✅ **智能工具选择**：直接从所有工具中选择合适的
- ✅ **执行策略制定**：规划工具使用的顺序和参数
- ✅ **上下文感知决策**：基于执行历史和失败经验做决策
- ✅ **结果分析决策**：分析执行结果并决定后续行动

### 11.3 解决的核心问题

#### 11.3.1 重复调用问题
**问题**：从轨迹数据可以看出，Agent经常重复执行相同的错误操作
```
step_id 1-15: 都在使用错误的选择器 "a.social-count"
每次thinking都重新开始，没有学习能力
```

**解决方案**：
- **ExecutionContext**: 维护执行历史和失败模式
- **失败模式学习**: 记录和避免重复相同的错误
- **参数自适应调整**: 基于失败原因自动调整参数
- **工具切换机制**: 在工具多次失败后主动切换

#### 11.3.2 缺乏上下文延续
**问题**：每次prompt调用都像是第一次，没有记忆前面的操作
```
"thinking": "The task requires..." // 每次都重新分析整个任务
没有基于前面的失败进行策略调整
```

**解决方案**：
- **上下文感知Prompt**: 包含失败历史和学习模式
- **渐进式决策**: 基于累积的观察结果做决策
- **智能重试机制**: 在重试前调整策略
- **替代工具推荐**: 当当前工具不可行时推荐替代方案

### 11.4 核心优势

1. **智能学习能力**：从失败中学习，避免重复错误
2. **上下文延续**：每次决策都基于完整的执行历史
3. **自适应调整**：根据执行结果动态调整策略
4. **高效决策**：减少无效的重复尝试
5. **简单实用**：避免过度设计，Agent直接面对工具选择
6. **易于扩展**：标签和元数据为将来的分级管理预留空间
7. **灵活部署**：支持Function Tools和MCP Server两种部署方式

### 11.5 实际应用效果

**传统方式**（轨迹数据中的问题）：
```
step 1: 尝试选择器 "a.social-count" → 失败
step 2: 再次尝试相同选择器 → 失败  
step 3-15: 重复相同错误 → 连续失败
结果：15步都在做无用功
```

**改进后的方式**：
```
step 1: 尝试选择器 "a.social-count" → 失败
step 2: 学习失败模式，尝试备用选择器 → 可能成功
step 3: 如果仍失败，切换到其他工具或重新规划
结果：快速收敛到可行方案
```

### 11.6 部署建议

1. **阶段1**：实现基础的执行上下文管理
2. **阶段2**：添加失败模式学习机制
3. **阶段3**：实现上下文感知的prompt设计
4. **阶段4**：添加智能工具切换和重规划能力

系统采用**简单实用的设计**，重点解决了Agent在实际执行中的**重复调用和缺乏记忆**问题，为Agent提供了**智能的、具有学习能力的工具选择和执行环境**，同时为将来的扩展保留了充分的空间。 