# MCPæœç´¢å·¥å…·ä¼˜åŒ–åˆ†æä¸è¿ç§»æ–¹æ¡ˆ

## é¡¹ç›®æ¦‚è¿°

æœ¬æ–‡æ¡£åŸºäºEnhanced Reasoning Runtimeçš„å·¥ä½œæœºåˆ¶ï¼ˆLLMæ ¹æ®æ¨ç†å†³å®šè°ƒç”¨å·¥å…·ï¼ŒæŸ¥çœ‹available toolså…ƒä¿¡æ¯è¿›è¡ŒåŒ¹é…ï¼Œä¸åŒ¹é…æ—¶è§¦å‘å·¥å…·æœç´¢æ³¨å†Œï¼‰ï¼Œåˆ†æå½“å‰MCPæœç´¢å·¥å…·çš„æ¶æ„é—®é¢˜ï¼Œå¹¶æä¾›ä¼˜åŒ–çš„å·¥å…·ç®¡ç†æ¶æ„å’Œè¿ç§»æ–¹æ¡ˆã€‚

## æ ¸å¿ƒå·¥ä½œæµç¨‹åˆ†æ

### Enhanced Reasoning Runtimeçš„å·¥å…·å†³ç­–æµç¨‹
```
ç”¨æˆ·ä»»åŠ¡ â†’ LLMæ¨ç†åˆ†æ â†’ æŸ¥çœ‹å½“å‰available tools
    â†“
æ˜¯å¦æœ‰åŒ¹é…çš„å·¥å…·ï¼Ÿ
â”œâ”€ æ˜¯ â†’ ç›´æ¥è°ƒç”¨å·¥å…·æ‰§è¡Œ
â””â”€ å¦ â†’ è§¦å‘MCPå·¥å…·æœç´¢ â†’ æ³¨å†Œæ–°å·¥å…· â†’ é‡æ–°æ‰§è¡Œ
```

### å·¥å…·æš´éœ²ç»™LLMçš„ä¿¡æ¯
- **å·¥å…·IDå’Œåç§°**: ç”¨äºLLMè¯†åˆ«å’Œé€‰æ‹©
- **å·¥å…·æè¿°**: è¯´æ˜å·¥å…·çš„åŠŸèƒ½å’Œç”¨é€”  
- **èƒ½åŠ›æ ‡ç­¾**: æ ‡è¯†å·¥å…·çš„æ ¸å¿ƒèƒ½åŠ›ï¼ˆå¦‚image_generation, web_scrapingï¼‰
- **å‚æ•°è§„æ ¼**: å·¥å…·æ¥å—çš„å‚æ•°æ ¼å¼å’Œçº¦æŸ
- **ä½¿ç”¨ç¤ºä¾‹**: å¸®åŠ©LLMæ­£ç¡®è°ƒç”¨å·¥å…·

## å½“å‰æ¶æ„åˆ†æ

### 1. ç°çŠ¶æ¶æ„å›¾

```
å½“å‰ç³»ç»Ÿæ¶æ„ (åŸºäºå®é™…ä»£ç åˆ†æ):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Enhanced Reasoning Runtime                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚ LLMæ¨ç†ä¸ä»»åŠ¡æ‰§è¡Œ                                       â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ LLMClient (ä»»åŠ¡æ¨ç†å’Œå·¥å…·é€‰æ‹©)                      â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ get_all_tools_description_for_agent() (å·¥å…·æš´éœ²)   â”‚â”‚
â”‚  â”‚ â””â”€â”€ execute_tool() (å·¥å…·è°ƒç”¨æ‰§è¡Œ)                       â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚ æœ¬åœ°å·¥å…·ç®¡ç† (é—®é¢˜æ‰€åœ¨)                                 â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ UnifiedToolLibrary (æœ¬åœ°å·¥å…·åº“)                    â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ mcp_search_tool (å†…ç½®MCPæœç´¢)                      â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ tool_gap_detector (å·¥å…·ç¼ºå£æ£€æµ‹)                   â”‚â”‚
â”‚  â”‚ â””â”€â”€ dynamic_mcp_manager (åŠ¨æ€MCPç®¡ç†)                  â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚ ToolScoreåŒæ­¥ (å½“å‰å®ç°)                                â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ ToolSyncManager (å·¥å…·åŒæ­¥)                         â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ ToolExecutionCoordinator (æ‰§è¡Œåè°ƒ)                â”‚â”‚
â”‚  â”‚ â””â”€â”€ WebSocketè¿æ¥åˆ°ToolScore                           â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚ å¤æ‚çš„åŒå‘åŒæ­¥
                             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        ToolScore                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚ ä¸­å¤®å·¥å…·æ³¨å†Œä¸­å¿ƒ                                         â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ UnifiedToolLibrary (ä¸­å¤®å·¥å…·åº“)                    â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ MonitoringAPI (/admin/tools/* endpoints)           â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ WebSocketå·¥å…·æ³¨å†ŒAPI                               â”‚â”‚
â”‚  â”‚ â””â”€â”€ Redis Pub/Subäº‹ä»¶ç³»ç»Ÿ                              â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚ MCPæœåŠ¡å™¨ç®¡ç† (éƒ¨åˆ†åŠŸèƒ½)                                â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ ç‹¬ç«‹MCPæœåŠ¡å™¨æ³¨å†Œ                                   â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ å·¥å…·ç”Ÿå‘½å‘¨æœŸç›‘æ§                                     â”‚â”‚
â”‚  â”‚ â””â”€â”€ åŸºç¡€ç¼“å­˜æœºåˆ¶                                         â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
                             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 ç‹¬ç«‹MCPæœåŠ¡å™¨                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚  â”‚Python        â”‚    â”‚Browser       â”‚                      â”‚
â”‚  â”‚Executor      â”‚    â”‚Navigator     â”‚                      â”‚
â”‚  â”‚Server        â”‚    â”‚Server        â”‚                      â”‚
â”‚  â”‚:8081         â”‚    â”‚:8082         â”‚                      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. å½“å‰é—®é¢˜è¯†åˆ«

#### æ¶æ„é—®é¢˜
- **åŒé‡å·¥å…·åº“**: Enhanced Reasoning Runtimeå’ŒToolScoreéƒ½ç»´æŠ¤UnifiedToolLibraryå®ä¾‹ï¼Œå¯¼è‡´çŠ¶æ€ä¸ä¸€è‡´
- **å¤æ‚åŒæ­¥æœºåˆ¶**: éœ€è¦é€šè¿‡ToolSyncManagerå’ŒWebSocketè¿›è¡ŒåŒå‘åŒæ­¥ï¼Œå¢åŠ å¤æ‚æ€§
- **å·¥å…·æš´éœ²æ•ˆç‡ä½**: LLMéœ€è¦çš„å·¥å…·æè¿°éœ€è¦ä»æœ¬åœ°ç¼“å­˜è·å–ï¼Œæ— æ³•å®æ—¶åæ˜ ToolScoreçš„æœ€æ–°çŠ¶æ€
- **èŒè´£ä¸æ¸…**: Runtimeæ—¢è¦åšæ¨ç†æ‰§è¡Œï¼Œåˆè¦ç®¡ç†å·¥å…·æ³¨å†Œï¼Œè¿åå•ä¸€èŒè´£åŸåˆ™

#### å…·ä½“æŠ€æœ¯é—®é¢˜
- **å·¥å…·å‘ç°å»¶è¿Ÿ**: LLMçœ‹åˆ°çš„available toolså¯èƒ½ä¸æ˜¯æœ€æ–°çš„ï¼Œéœ€è¦æ‰‹åŠ¨åŒæ­¥
- **é‡å¤çš„å·¥å…·ç®¡ç†é€»è¾‘**: mcp_tool_search, tool_gap_detector, dynamic_mcp_manageråœ¨Runtimeä¸­é‡å¤å®ç°
- **ç¼“å­˜ä¸ä¸€è‡´**: GitHub APIæœç´¢ç»“æœåœ¨å¤šä¸ªæœåŠ¡ä¸­é‡å¤ç¼“å­˜ï¼Œæµªè´¹èµ„æº
- **å®‰å…¨ç­–ç•¥åˆ†æ•£**: MCPæœåŠ¡å™¨å®‰å…¨éªŒè¯é€»è¾‘åˆ†æ•£åœ¨å„ä¸ªRuntimeä¸­

#### åŸºäºå·¥ä½œæµç¨‹çš„ç—›ç‚¹
1. **å·¥å…·å¯è§æ€§é—®é¢˜**: LLMå†³ç­–ä¾èµ–`get_all_tools_description_for_agent()`ï¼Œä½†è¯¥æ–¹æ³•å¯èƒ½è¿”å›è¿‡æ—¶ä¿¡æ¯
2. **å·¥å…·æ³¨å†Œå»¶è¿Ÿ**: æ–°æ³¨å†Œçš„MCPæœåŠ¡å™¨éœ€è¦ç­‰å¾…åŒæ­¥æ‰èƒ½è¢«LLMçœ‹åˆ°
3. **æ•…éšœæ¢å¤å¤æ‚**: å¦‚æœåŒæ­¥å¤±è´¥ï¼ŒRuntimeå’ŒToolScoreçš„å·¥å…·çŠ¶æ€ä¼šåˆ†æ­§
4. **æ‰©å±•å›°éš¾**: æ–°å¢å…¶ä»–Runtimeéœ€è¦é‡æ–°å®ç°ç›¸åŒçš„å·¥å…·ç®¡ç†å’ŒåŒæ­¥é€»è¾‘

## ç›®æ ‡æ¶æ„è®¾è®¡

### 1. ä¼˜åŒ–åæ¶æ„å›¾

```
ç›®æ ‡ç³»ç»Ÿæ¶æ„ (ç®€åŒ–ä¸”é«˜æ•ˆ):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Enhanced Reasoning Runtime                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚ æ ¸å¿ƒLLMæ¨ç†ä¸æ‰§è¡Œ (ä¸“æ³¨å•ä¸€èŒè´£)                        â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ LLMClient (ä»»åŠ¡æ¨ç†å’Œå·¥å…·é€‰æ‹©å†³ç­–)                  â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ TaskExecution (ä»»åŠ¡åˆ†è§£ä¸æ‰§è¡Œåè°ƒ)                  â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ TrajectoryManager (æ‰§è¡Œè½¨è¿¹ç®¡ç†)                    â”‚â”‚
â”‚  â”‚ â””â”€â”€ MetricsCollector (æ€§èƒ½æŒ‡æ ‡æ”¶é›†)                     â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚ è½»é‡çº§ToolScoreå®¢æˆ·ç«¯ (çº¯APIè°ƒç”¨)                       â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ get_available_tools() â†’ ToolScore API              â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ request_tool_installation() â†’ ToolScore API        â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ execute_tool() â†’ ç›´æ¥è°ƒç”¨MCP Server                â”‚â”‚
â”‚  â”‚ â””â”€â”€ WebSocketäº‹ä»¶ç›‘å¬ (å·¥å…·å˜æ›´é€šçŸ¥)                    â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚ ç®€å•çš„HTTP APIè°ƒç”¨
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 ToolScore (å”¯ä¸€æƒå¨)                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚ ç»Ÿä¸€å·¥å…·æ³¨å†Œä¸­å¿ƒ                                         â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ UnifiedToolLibrary (å”¯ä¸€å®ä¾‹)                      â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ GET /api/v1/tools/available (LLMå·¥å…·åˆ—è¡¨)         â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ POST /api/v1/tools/request-capability (å·¥å…·éœ€æ±‚)  â”‚â”‚
â”‚  â”‚ â””â”€â”€ WebSocket /events (å®æ—¶å·¥å…·å˜æ›´é€šçŸ¥)                â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚ é›†ä¸­å¼MCPå·¥å…·å‘ç°ä¸ç®¡ç† (ä»Runtimeè¿ç§»)                 â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ mcp_tool_search (GitHub/ç¤¾åŒºæœç´¢)                  â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ tool_gap_detector (LLMèƒ½åŠ›åˆ†æ)                    â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ dynamic_mcp_manager (åŠ¨æ€å®‰è£…ç®¡ç†)                 â”‚â”‚
â”‚  â”‚ â””â”€â”€ mcp_cache_manager (ç»Ÿä¸€ç¼“å­˜ç­–ç•¥)                   â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚ å·¥å…·ç”Ÿå‘½å‘¨æœŸç®¡ç†                                         â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ å·¥å…·å¥åº·æ£€æŸ¥ä¸çŠ¶æ€ç›‘æ§                               â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ å®‰å…¨ç­–ç•¥é›†ä¸­ç®¡ç†                                     â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ æ€§èƒ½ç›‘æ§ä¸èµ„æºé™åˆ¶                                   â”‚â”‚
â”‚  â”‚ â””â”€â”€ å·¥å…·ç‰ˆæœ¬ç®¡ç†ä¸æ›´æ–°                                   â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚ ç»Ÿä¸€ç®¡ç†æ‰€æœ‰MCPæœåŠ¡å™¨
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    MCPæœåŠ¡å™¨é›†ç¾¤                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚Python        â”‚ â”‚Browser       â”‚ â”‚Dynamic       â”‚        â”‚
â”‚  â”‚Executor      â”‚ â”‚Navigator     â”‚ â”‚Installed     â”‚        â”‚
â”‚  â”‚:8081         â”‚ â”‚:8082         â”‚ â”‚Servers       â”‚        â”‚
â”‚  â”‚(é¢„ç½®)        â”‚ â”‚(é¢„ç½®)        â”‚ â”‚(8100-8200)   â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. æ ¸å¿ƒè®¾è®¡åŸåˆ™

#### å•ä¸€èŒè´£åŸåˆ™ (ä¸“æ³¨æ ¸å¿ƒèƒ½åŠ›)
- **Enhanced Reasoning Runtime**: ä¸“æ³¨LLMæ¨ç†ã€ä»»åŠ¡æ‰§è¡Œã€è½¨è¿¹ç®¡ç†
- **ToolScore**: ä¸“é—¨è´Ÿè´£å·¥å…·å‘ç°ã€æ³¨å†Œã€ç”Ÿå‘½å‘¨æœŸç®¡ç†ã€ç¼“å­˜ä¼˜åŒ–
- **MCP Servers**: ä¸“é—¨æä¾›ç‰¹å®šé¢†åŸŸçš„å·¥å…·èƒ½åŠ›

#### ç®€åŒ–äº¤äº’æ¨¡å¼ (å‡å°‘å¤æ‚æ€§)
- **APIä¼˜å…ˆ**: Runtimeé€šè¿‡ç®€å•çš„HTTP APIè·å–å·¥å…·ä¿¡æ¯ï¼Œæ— éœ€å¤æ‚åŒæ­¥
- **äº‹ä»¶é€šçŸ¥**: å·¥å…·å˜æ›´é€šè¿‡WebSocketä¸»åŠ¨æ¨é€ï¼ŒRuntimeè¢«åŠ¨æ¥æ”¶
- **ç›´æ¥è°ƒç”¨**: å·¥å…·æ‰§è¡Œç›´æ¥è°ƒç”¨MCP Serverï¼Œæ— éœ€ä¸­é—´å±‚è½¬å‘

#### ä¸­å¤®æƒå¨æ¨¡å¼ (ç¡®ä¿ä¸€è‡´æ€§)
- **å•ä¸€æ•°æ®æº**: ToolScoreæ˜¯å·¥å…·çŠ¶æ€çš„å”¯ä¸€æƒå¨æº
- **é›†ä¸­ç¼“å­˜**: æ‰€æœ‰GitHub APIã€æœç´¢ç»“æœåœ¨ToolScoreç»Ÿä¸€ç¼“å­˜
- **ç»Ÿä¸€å®‰å…¨ç­–ç•¥**: MCPæœåŠ¡å™¨å®‰å…¨éªŒè¯åœ¨ToolScoreé›†ä¸­ç®¡ç†

#### åŸºäºå·¥ä½œæµç¨‹ä¼˜åŒ– (æå‡LLMä½“éªŒ)
- **å®æ—¶å·¥å…·å¯è§æ€§**: LLMæ€»æ˜¯èƒ½çœ‹åˆ°æœ€æ–°çš„available tools
- **å¿«é€Ÿå·¥å…·è·å–**: ä¼˜åŒ–`get_available_tools()`APIçš„å“åº”é€Ÿåº¦
- **æ™ºèƒ½å·¥å…·æ¨è**: åŸºäºä»»åŠ¡åˆ†æä¸»åŠ¨æ¨èåˆé€‚çš„å·¥å…·

## ä¼˜åŒ–çš„è¿ç§»å®æ–½æ–¹æ¡ˆ

### å·¥å…·ç®¡ç†æƒå¨åˆ†é…
æ ¹æ®æ‚¨çš„éœ€æ±‚å’Œå½“å‰å·¥ä½œæµç¨‹ï¼Œæ‰€æœ‰MCPæœåŠ¡å™¨çš„æ³¨å†Œã€ç®¡ç†éƒ½åº”è¯¥æ”¾åœ¨**ToolScore**ä¸­ï¼ŒEnhanced Reasoning Runtimeä½œä¸ºçº¯ç²¹çš„å·¥å…·æ¶ˆè´¹è€…ã€‚

### Phase 1: ToolScoreæ‰©å±•ä¸ºå®Œæ•´å·¥å…·ç®¡ç†ä¸­å¿ƒ

#### 1.1 è¿ç§»æ ¸å¿ƒæ¨¡å—åˆ°ToolScore

```python
# ä»Enhanced Runtimeè¿ç§»åˆ°ToolScore
core/toolscore/
â”œâ”€â”€ mcp_search_tool.py          # è¿ç§»: MCPå·¥å…·æœç´¢å’Œå®‰è£…
â”œâ”€â”€ tool_gap_detector.py        # è¿ç§»: å·¥å…·ç¼ºå£æ£€æµ‹  
â”œâ”€â”€ dynamic_mcp_manager.py      # å¢å¼º: åŠ¨æ€MCPç”Ÿå‘½å‘¨æœŸç®¡ç†
â”œâ”€â”€ mcp_cache_manager.py        # æ–°å¢: ç»Ÿä¸€ç¼“å­˜ç®¡ç†
â””â”€â”€ tool_discovery_api.py       # æ–°å¢: å·¥å…·å‘ç°ä¸“ç”¨APIå±‚
```

#### 1.2 ä¼˜åŒ–APIç«¯ç‚¹ (åŸºäºLLMå·¥ä½œæµç¨‹)

```python
# æ ¸å¿ƒAPIç«¯ç‚¹ - ä¸“é—¨ä¸ºLLMå·¥ä½œæµç¨‹è®¾è®¡
GET /api/v1/tools/available
    # è¿”å›æ ¼å¼åŒ–çš„å·¥å…·åˆ—è¡¨ï¼Œç›´æ¥ç”¨äºLLMå†³ç­–
    # åŒ…å«: tool_id, name, description, capabilities, parameters, examples
    
POST /api/v1/tools/request-capability
    # ä¸€ç«™å¼å·¥å…·è·å–æœåŠ¡ - LLMå‘ç°ç¼ºå°‘å·¥å…·æ—¶è°ƒç”¨
    # è‡ªåŠ¨æ‰§è¡Œ: åˆ†æéœ€æ±‚ â†’ æœç´¢MCP â†’ å®‰è£… â†’ æ³¨å†Œ â†’ è¿”å›æ–°å·¥å…·
    
GET /api/v1/tools/{tool_id}/detail
    # è·å–ç‰¹å®šå·¥å…·çš„è¯¦ç»†ä¿¡æ¯
    
POST /api/v1/tools/execute/{tool_id}  
    # å·¥å…·æ‰§è¡Œä»£ç† (å¯é€‰ï¼Œä¹Ÿå¯ç›´æ¥è°ƒç”¨MCP Server)
    
WebSocket /api/v1/events/tools
    # å®æ—¶å·¥å…·å˜æ›´é€šçŸ¥ (æ–°å¢/åˆ é™¤/çŠ¶æ€å˜åŒ–)
```

#### 1.3 ç¼“å­˜æœºåˆ¶è®¾è®¡

```python
# Redisç¼“å­˜é”®è®¾è®¡
tool_discovery:github_api:{query_hash}     # GitHub APIç»“æœç¼“å­˜
tool_discovery:mcp_search:{capability}     # MCPæœç´¢ç»“æœç¼“å­˜  
tool_discovery:gap_analysis:{task_hash}    # å·¥å…·ç¼ºå£åˆ†æç¼“å­˜
tool_discovery:security_check:{repo_url}   # å®‰å…¨éªŒè¯ç»“æœç¼“å­˜
```

### Phase 2: Enhanced Reasoning Runtimeç®€åŒ–é‡æ„

#### 2.1 å®Œå…¨ç§»é™¤å†…ç½®å·¥å…·ç®¡ç†æ¨¡å—

```python
# ä»Enhanced Runtimeå®Œå…¨ç§»é™¤:
âŒ self.tool_library = UnifiedToolLibrary()     # ç§»é™¤æœ¬åœ°å·¥å…·åº“
âŒ self.mcp_search_tool = MCPSearchTool()       # ç§»é™¤MCPæœç´¢
âŒ self.tool_gap_detector = ToolGapDetector()   # ç§»é™¤å·¥å…·ç¼ºå£æ£€æµ‹
âŒ self.dynamic_mcp_manager = DynamicMCPManager() # ç§»é™¤åŠ¨æ€MCPç®¡ç†
âŒ self.tool_sync_manager = ToolSyncManager()   # ç§»é™¤å¤æ‚åŒæ­¥æœºåˆ¶
âŒ self.execution_coordinator = ToolExecutionCoordinator() # ç§»é™¤æ‰§è¡Œåè°ƒå™¨
```

#### 2.2 æ–°å¢è½»é‡çº§ToolScoreå®¢æˆ·ç«¯

```python
# æ–°å¢ç®€å•é«˜æ•ˆçš„å®¢æˆ·ç«¯
runtimes/reasoning/toolscore_client.py
class ToolScoreClient:
    def __init__(self, toolscore_endpoint: str):
        self.endpoint = toolscore_endpoint
        self.session = aiohttp.ClientSession()
        self.websocket = None  # ç”¨äºæ¥æ”¶å·¥å…·å˜æ›´é€šçŸ¥
    
    async def get_available_tools_for_llm(self) -> str:
        """è·å–æ ¼å¼åŒ–çš„å·¥å…·åˆ—è¡¨ï¼Œç›´æ¥ç”¨äºLLM Prompt"""
        response = await self.session.get(f"{self.endpoint}/api/v1/tools/available")
        return response.json()["formatted_tools_description"]
    
    async def request_tool_capability(self, task_description: str, required_capabilities: List[str]) -> dict:
        """è¯·æ±‚ç‰¹å®šèƒ½åŠ›çš„å·¥å…· - ä¸€ç«™å¼æœåŠ¡"""
        return await self.session.post(f"{self.endpoint}/api/v1/tools/request-capability", json={
            "task_description": task_description,
            "required_capabilities": required_capabilities,
            "auto_install": True
        })
    
    async def execute_tool_via_mcp(self, tool_id: str, action: str, parameters: dict) -> dict:
        """ç›´æ¥è°ƒç”¨MCPæœåŠ¡å™¨æ‰§è¡Œå·¥å…·"""
        # è·å–å·¥å…·çš„MCPç«¯ç‚¹ä¿¡æ¯
        tool_info = await self.session.get(f"{self.endpoint}/api/v1/tools/{tool_id}/detail")
        mcp_endpoint = tool_info.json()["mcp_endpoint"]
        
        # ç›´æ¥è°ƒç”¨MCPæœåŠ¡å™¨
        return await self._call_mcp_server(mcp_endpoint, action, parameters)
```

#### 2.3 é‡æ„æ ¸å¿ƒå·¥ä½œæµç¨‹

```python
# ä¼˜åŒ–åçš„Enhanced Runtimeæ ¸å¿ƒé€»è¾‘
class EnhancedReasoningRuntime:
    def __init__(self):
        self.llm_client = LLMClient()
        self.toolscore_client = ToolScoreClient("http://toolscore:8090")
        # ç§»é™¤æ‰€æœ‰å·¥å…·ç®¡ç†ç›¸å…³ç»„ä»¶
    
    async def execute(self, task: TaskSpec) -> TrajectoryResult:
        """ç®€åŒ–çš„æ‰§è¡Œæµç¨‹"""
        trajectory = TrajectoryResult(task_id=task.task_id)
        
        while not task_completed:
            # 1. è·å–å½“å‰å¯ç”¨å·¥å…·ç»™LLM
            available_tools = await self.toolscore_client.get_available_tools_for_llm()
            
            # 2. LLMæ¨ç†å†³ç­–
            llm_decision = await self.llm_client.reason_and_decide(
                task_description=task.description,
                available_tools=available_tools,
                previous_steps=trajectory.steps
            )
            
            # 3. æ ¹æ®LLMå†³ç­–æ‰§è¡Œ
            if llm_decision.action_type == "use_existing_tool":
                # ç›´æ¥ä½¿ç”¨ç°æœ‰å·¥å…·
                result = await self.toolscore_client.execute_tool_via_mcp(
                    llm_decision.tool_id, 
                    llm_decision.action, 
                    llm_decision.parameters
                )
                
            elif llm_decision.action_type == "need_new_tool":
                # è¯·æ±‚æ–°å·¥å…·èƒ½åŠ›
                install_result = await self.toolscore_client.request_tool_capability(
                    task.description,
                    llm_decision.required_capabilities
                )
                
                if install_result["success"]:
                    # é‡æ–°è·å–å·¥å…·åˆ—è¡¨ï¼Œç»§ç»­æ‰§è¡Œ
                    continue
                else:
                    # å¤„ç†å·¥å…·è·å–å¤±è´¥
                    pass
        
        return trajectory
```

### Phase 3: å‘åå…¼å®¹ä¸æ¸è¿›è¿ç§»

#### 3.1 åŒæ¨¡å¼æ”¯æŒ

```python
# é…ç½®é€‰é¡¹
MCP_SEARCH_MODE=["local", "remote", "hybrid"]
# - local: ä½¿ç”¨åŸæœ‰å†…ç½®æ¨¡å—
# - remote: ä½¿ç”¨ToolScore API
# - hybrid: ä¼˜å…ˆä½¿ç”¨remoteï¼Œå¤±è´¥æ—¶fallbackåˆ°local
```

#### 3.2 æ¸è¿›è¿ç§»æ­¥éª¤

1. **Week 1-2**: åœ¨ToolScoreä¸­å®ç°æ–°åŠŸèƒ½
2. **Week 3**: Enhanced Reasoning Runtimeæ·»åŠ åŒæ¨¡å¼æ”¯æŒ
3. **Week 4**: å…¨é¢æµ‹è¯•å’Œæ€§èƒ½éªŒè¯
4. **Week 5**: åˆ‡æ¢åˆ°remoteæ¨¡å¼
5. **Week 6**: ç§»é™¤æ—§ä»£ç ï¼Œæ¸…ç†æŠ€æœ¯å€ºåŠ¡

## è¯¦ç»†æŠ€æœ¯è§„èŒƒ

### 1. ToolScore APIè§„èŒƒ

#### 1.1 å·¥å…·ç¼ºå£åˆ†æAPI

```yaml
POST /api/v1/tools/analyze-gap
Content-Type: application/json

Request:
{
  "task_description": "ç”Ÿæˆä¸€å¼ å¡é€šé£æ ¼çš„çŒ«å’ªå›¾ç‰‡",
  "current_tools": [
    {
      "tool_id": "python-executor",
      "capabilities": ["code_execution", "data_processing"]
    }
  ],
  "context": {
    "user_preferences": ["high_quality", "fast_generation"],
    "constraints": ["no_nsfw", "family_friendly"]
  }
}

Response:
{
  "has_sufficient_tools": false,
  "gap_analysis": {
    "missing_capabilities": ["image_generation", "ai_art"],
    "confidence_score": 0.95,
    "reasoning": "ä»»åŠ¡éœ€è¦å›¾åƒç”Ÿæˆèƒ½åŠ›ï¼Œå½“å‰å·¥å…·åº“ä¸­ç¼ºå°‘æ­¤ç±»å·¥å…·"
  },
  "recommendations": [
    {
      "capability": "image_generation",
      "priority": "high",
      "suggested_keywords": ["dalle", "stable-diffusion", "image-ai"]
    }
  ],
  "cache_info": {
    "cached": true,
    "cache_age_seconds": 120
  }
}
```

#### 1.2 å·¥å…·èƒ½åŠ›è¯·æ±‚API (ä¸€ç«™å¼æœåŠ¡)

```yaml
POST /api/v1/tools/request-capability
Content-Type: application/json

Request:
{
  "task_description": "ç”Ÿæˆä¸€å¼ å¡é€šé£æ ¼çš„çŒ«å’ªå›¾ç‰‡", 
  "required_capabilities": ["image_generation"],
  "current_tools": [...],
  "auto_install": true,
  "security_level": "high"
}

Response:
{
  "success": true,
  "action_taken": "installed_new_tools",
  "installed_tools": [
    {
      "tool_id": "stable-diffusion-mcp",
      "name": "Stable Diffusion MCP Server",
      "capabilities": ["image_generation", "ai_art"],
      "installation_time": "2024-01-20T10:30:00Z",
      "server_endpoint": "ws://stable-diffusion-mcp:8090/mcp"
    }
  ],
  "total_available_tools": 4,
  "processing_time_ms": 2500
}
```

### 2. ç¼“å­˜ç­–ç•¥è®¾è®¡

#### 2.1 å¤šå±‚ç¼“å­˜æ¶æ„

```python
# L1: å†…å­˜ç¼“å­˜ (æœ€å¿«ï¼Œå®¹é‡å°)
memory_cache = {
    "tool_gap_analysis": TTL(300),  # 5åˆ†é’Ÿ
    "frequent_searches": TTL(600)   # 10åˆ†é’Ÿ  
}

# L2: Redisç¼“å­˜ (å¿«é€Ÿï¼Œå®¹é‡ä¸­ç­‰)
redis_cache = {
    "github_api_results": TTL(3600),      # 1å°æ—¶
    "mcp_search_results": TTL(1800),      # 30åˆ†é’Ÿ
    "security_validations": TTL(86400)    # 24å°æ—¶
}

# L3: æŒä¹…åŒ–ç¼“å­˜ (æ…¢ä½†å¯é )
persistent_cache = {
    "known_mcp_servers": "æ°¸ä¹…å­˜å‚¨",
    "security_whitelist": "æ°¸ä¹…å­˜å‚¨"
}
```

#### 2.2 ç¼“å­˜å¤±æ•ˆç­–ç•¥

```python
# åŸºäºæ—¶é—´çš„å¤±æ•ˆ
- GitHub APIç»“æœ: 1å°æ—¶åå¤±æ•ˆ
- å®‰å…¨éªŒè¯ç»“æœ: 24å°æ—¶åå¤±æ•ˆ

# åŸºäºäº‹ä»¶çš„å¤±æ•ˆ  
- æ–°MCPæœåŠ¡å™¨å®‰è£…: æ¸…ç©ºç›¸å…³æœç´¢ç¼“å­˜
- å·¥å…·æ³¨å†ŒçŠ¶æ€å˜åŒ–: æ¸…ç©ºèƒ½åŠ›åŒ¹é…ç¼“å­˜

# åŸºäºå®¹é‡çš„å¤±æ•ˆ
- LRUç­–ç•¥: æœ€å°‘ä½¿ç”¨çš„ç»“æœä¼˜å…ˆæ¸…ç†
- å†…å­˜å‹åŠ›: è‡ªåŠ¨é™çº§åˆ°æ›´å°çš„ç¼“å­˜é›†åˆ
```

### 3. å®‰å…¨ä¸æƒé™ç®¡ç†

#### 3.1 MCPæœåŠ¡å™¨å®‰å…¨åˆ†çº§

```python
SecurityLevel = {
    "high": {
        "trusted_authors": ["anthropic", "microsoft", "google"],
        "require_code_review": True,
        "sandbox_execution": True,
        "resource_limits": "strict"
    },
    "medium": {
        "min_stars": 100,
        "min_contributors": 5,
        "require_readme": True,
        "resource_limits": "moderate"
    },
    "low": {
        "basic_validation": True,
        "resource_limits": "relaxed"
    }
}
```

#### 3.2 å®‰è£…æƒé™æ§åˆ¶

```python
InstallPermissions = {
    "auto_install": {
        "max_tools_per_session": 3,
        "max_daily_installs": 10,
        "security_level_required": "high"
    },
    "manual_approval": {
        "medium_security_tools": True,
        "untrusted_authors": True,
        "resource_intensive_tools": True
    }
}
```

## æ€§èƒ½ä¼˜åŒ–è®¾è®¡

### 1. å¹¶å‘å¤„ç†

```python
# å¹¶è¡Œæœç´¢ç­–ç•¥
async def parallel_mcp_search(query, strategies):
    tasks = [
        search_official_registry(query),
        search_github_repos(query), 
        search_community_sources(query)
    ]
    results = await asyncio.gather(*tasks, return_exceptions=True)
    return merge_and_rank_results(results)
```

### 2. æ™ºèƒ½é¢„åŠ è½½

```python
# åŸºäºå†å²æ¨¡å¼çš„é¢„åŠ è½½
PreloadStrategy = {
    "popular_combinations": [
        ["image_generation", "file_processing"],
        ["web_scraping", "data_analysis"],
        ["code_execution", "testing"]
    ],
    "user_patterns": "åŸºäºç”¨æˆ·å†å²åå¥½é¢„åŠ è½½",
    "seasonal_trends": "åŸºäºå­£èŠ‚æ€§éœ€æ±‚é¢„åŠ è½½"
}
```

### 3. æ€§èƒ½ç›‘æ§

```python
# å…³é”®æ€§èƒ½æŒ‡æ ‡
PerformanceMetrics = {
    "tool_discovery_latency": "å·¥å…·å‘ç°å“åº”æ—¶é—´",
    "cache_hit_ratio": "ç¼“å­˜å‘½ä¸­ç‡", 
    "installation_success_rate": "å®‰è£…æˆåŠŸç‡",
    "api_rate_limit_usage": "APIé™åˆ¶ä½¿ç”¨æƒ…å†µ"
}
```

## æµ‹è¯•ç­–ç•¥

### 1. å•å…ƒæµ‹è¯•

```python
# æµ‹è¯•è¦†ç›–èŒƒå›´
test_coverage = {
    "tool_gap_detector": "å·¥å…·ç¼ºå£æ£€æµ‹é€»è¾‘",
    "mcp_search_engine": "æœç´¢ç®—æ³•å‡†ç¡®æ€§",
    "cache_manager": "ç¼“å­˜ä¸€è‡´æ€§å’Œå¤±æ•ˆ",
    "security_validator": "å®‰å…¨éªŒè¯é€»è¾‘",
    "api_endpoints": "APIæ¥å£åŠŸèƒ½å’Œé”™è¯¯å¤„ç†"
}
```

### 2. é›†æˆæµ‹è¯•

```python
# ç«¯åˆ°ç«¯æµ‹è¯•åœºæ™¯
integration_tests = [
    "æ–°ç”¨æˆ·é¦–æ¬¡ä½¿ç”¨å›¾åƒç”Ÿæˆä»»åŠ¡",
    "é«˜é¢‘ç”¨æˆ·é‡å¤ä»»åŠ¡çš„ç¼“å­˜æ•ˆæœ",
    "ç½‘ç»œå¼‚å¸¸æ—¶çš„é™çº§å¤„ç†",
    "å¹¶å‘ç”¨æˆ·åŒæ—¶è¯·æ±‚ç›¸åŒå·¥å…·",
    "å®‰å…¨å·¥å…·è¢«æ‹’ç»å®‰è£…çš„æµç¨‹"
]
```

### 3. æ€§èƒ½æµ‹è¯•

```python
# è´Ÿè½½æµ‹è¯•æŒ‡æ ‡
load_test_scenarios = {
    "concurrent_users": 50,
    "requests_per_second": 100, 
    "average_response_time": "<500ms",
    "95th_percentile_response_time": "<1000ms",
    "error_rate": "<1%"
}
```

## é£é™©è¯„ä¼°ä¸ç¼“è§£

### 1. æŠ€æœ¯é£é™©

| é£é™©é¡¹ | æ¦‚ç‡ | å½±å“ | ç¼“è§£ç­–ç•¥ |
|--------|------|------|----------|
| APIé™åˆ¶å¯¼è‡´æœç´¢å¤±è´¥ | ä¸­ | é«˜ | å¤šæºæœç´¢ + ç¼“å­˜ + é™æµ |
| æ–°æ¶æ„æ€§èƒ½ä¸‹é™ | ä¸­ | ä¸­ | æ€§èƒ½åŸºå‡†æµ‹è¯• + ä¼˜åŒ– |
| ç¼“å­˜ä¸€è‡´æ€§é—®é¢˜ | ä½ | é«˜ | ç‰ˆæœ¬æ§åˆ¶ + äº‹ä»¶é©±åŠ¨å¤±æ•ˆ |
| å®‰å…¨éªŒè¯ç»•è¿‡ | ä½ | é«˜ | å¤šå±‚éªŒè¯ + å®¡è®¡æ—¥å¿— |

### 2. ä¸šåŠ¡é£é™©

| é£é™©é¡¹ | æ¦‚ç‡ | å½±å“ | ç¼“è§£ç­–ç•¥ |
|--------|------|------|----------|
| è¿ç§»æœŸé—´æœåŠ¡ä¸­æ–­ | ä½ | é«˜ | æ¸è¿›è¿ç§» + åŒæ¨¡å¼è¿è¡Œ |
| ç”¨æˆ·ä½“éªŒä¸‹é™ | ä¸­ | ä¸­ | å……åˆ†æµ‹è¯• + ç”¨æˆ·åé¦ˆ |
| å‘åå…¼å®¹æ€§é—®é¢˜ | ä¸­ | ä¸­ | å…¼å®¹å±‚ + ç‰ˆæœ¬ç®¡ç† |

## å®æ–½æ—¶é—´çº¿

### Week 1: ToolScoreæ‰©å±•å¼€å‘
**ç›®æ ‡**: å°†ToolScoreæ‰“é€ ä¸ºå®Œæ•´çš„å·¥å…·ç®¡ç†ä¸­å¿ƒ

- [ ] **è¿ç§»æ ¸å¿ƒæ¨¡å—**: å°†`mcp_search_tool.py`, `tool_gap_detector.py`, `dynamic_mcp_manager.py`ä»Enhanced Runtimeè¿ç§»åˆ°ToolScore
- [ ] **æ–°å¢APIç«¯ç‚¹**: å®ç°`GET /api/v1/tools/available`å’Œ`POST /api/v1/tools/request-capability`
- [ ] **å·¥å…·æè¿°ä¼˜åŒ–**: ä¼˜åŒ–å·¥å…·æè¿°æ ¼å¼ï¼Œç¡®ä¿LLMèƒ½å‡†ç¡®ç†è§£å’Œé€‰æ‹©å·¥å…·
- [ ] **ç¼“å­˜æœºåˆ¶**: å®ç°`mcp_cache_manager.py`ï¼Œç»Ÿä¸€ç®¡ç†GitHub APIå’Œæœç´¢ç»“æœç¼“å­˜
- [ ] **WebSocketäº‹ä»¶**: å®ç°å·¥å…·å˜æ›´çš„å®æ—¶é€šçŸ¥æœºåˆ¶

### Week 2: Enhanced Reasoning Runtimeç®€åŒ–
**ç›®æ ‡**: å°†Runtimeè½¬æ¢ä¸ºçº¯ç²¹çš„LLMæ¨ç†å’Œæ‰§è¡Œå¼•æ“

- [ ] **ç§»é™¤å·¥å…·ç®¡ç†**: åˆ é™¤æ‰€æœ‰å†…ç½®å·¥å…·ç®¡ç†ç»„ä»¶(UnifiedToolLibrary, MCPSearchToolç­‰)
- [ ] **å®ç°ToolScoreClient**: åˆ›å»ºè½»é‡çº§HTTPå®¢æˆ·ç«¯ï¼Œä¸“æ³¨APIè°ƒç”¨
- [ ] **é‡æ„executeæ–¹æ³•**: ç®€åŒ–æ‰§è¡Œæµç¨‹ï¼ŒåŸºäºToolScore APIè¿›è¡Œå·¥å…·è·å–å’Œè°ƒç”¨
- [ ] **ä¿ç•™MCPè°ƒç”¨**: ä¿æŒç›´æ¥è°ƒç”¨MCPæœåŠ¡å™¨çš„èƒ½åŠ›ï¼Œæå‡æ‰§è¡Œæ•ˆç‡
- [ ] **é”™è¯¯å¤„ç†ä¼˜åŒ–**: ä¼˜åŒ–å·¥å…·è·å–å¤±è´¥æ—¶çš„å¤„ç†é€»è¾‘

### Week 3: æµ‹è¯•ä¸éªŒè¯
**ç›®æ ‡**: ç¡®ä¿æ–°æ¶æ„çš„ç¨³å®šæ€§å’Œæ€§èƒ½

- [ ] **åŠŸèƒ½æµ‹è¯•**: éªŒè¯å·¥å…·å‘ç°ã€å®‰è£…ã€è°ƒç”¨çš„å®Œæ•´æµç¨‹
- [ ] **æ€§èƒ½æµ‹è¯•**: å¯¹æ¯”æ–°æ—§æ¶æ„çš„å“åº”æ—¶é—´å’Œèµ„æºä½¿ç”¨
- [ ] **LLMå·¥ä½œæµç¨‹æµ‹è¯•**: ç¡®ä¿LLMèƒ½æ­£ç¡®è·å–å’Œé€‰æ‹©å·¥å…·
- [ ] **å¹¶å‘æµ‹è¯•**: æµ‹è¯•å¤šä¸ªRuntimeåŒæ—¶è¯·æ±‚å·¥å…·çš„åœºæ™¯
- [ ] **æ•…éšœæ¢å¤æµ‹è¯•**: æµ‹è¯•ToolScoreæš‚æ—¶ä¸å¯ç”¨æ—¶çš„é™çº§å¤„ç†

### Week 4: éƒ¨ç½²ä¸ç›‘æ§
**ç›®æ ‡**: å¹³æ»‘ä¸Šçº¿å¹¶å»ºç«‹ç›‘æ§ä½“ç³»

- [ ] **åˆ†é˜¶æ®µéƒ¨ç½²**: å…ˆéƒ¨ç½²ToolScoreæ–°åŠŸèƒ½ï¼Œå†åˆ‡æ¢Runtime
- [ ] **ç›‘æ§æŒ‡æ ‡**: å»ºç«‹å·¥å…·å‘ç°æˆåŠŸç‡ã€å“åº”æ—¶é—´ç­‰å…³é”®æŒ‡æ ‡
- [ ] **å›æ»šå‡†å¤‡**: å‡†å¤‡å¿«é€Ÿå›æ»šæ–¹æ¡ˆï¼Œç¡®ä¿æœåŠ¡ç¨³å®šæ€§
- [ ] **æ–‡æ¡£æ›´æ–°**: æ›´æ–°APIæ–‡æ¡£å’Œä½¿ç”¨æŒ‡å—
- [ ] **å›¢é˜ŸåŸ¹è®­**: åŸ¹è®­å›¢é˜Ÿæˆå‘˜æ–°çš„æ¶æ„å’Œæ“ä½œæ–¹å¼

## æˆåŠŸæŒ‡æ ‡

### 1. æŠ€æœ¯æŒ‡æ ‡
- [ ] APIå“åº”æ—¶é—´ < 500ms (95th percentile)
- [ ] ç¼“å­˜å‘½ä¸­ç‡ > 80%
- [ ] å·¥å…·å‘ç°æˆåŠŸç‡ > 95%
- [ ] ç³»ç»Ÿå¯ç”¨æ€§ > 99.9%

### 2. ä¸šåŠ¡æŒ‡æ ‡  
- [ ] ç”¨æˆ·ä»»åŠ¡å®Œæˆç‡æå‡ 10%
- [ ] æ–°å·¥å…·å®‰è£…æˆåŠŸç‡ > 90%
- [ ] ç”¨æˆ·æ»¡æ„åº¦è¯„åˆ† > 4.5/5
- [ ] é—®é¢˜åé¦ˆå‡å°‘ 20%

### 3. è¿ç»´æŒ‡æ ‡
- [ ] éƒ¨ç½²æ—¶é—´å‡å°‘ 50%
- [ ] ä»£ç ç»´æŠ¤å·¥ä½œé‡å‡å°‘ 30%
- [ ] ç³»ç»Ÿå¤æ‚åº¦é™ä½ (åœˆå¤æ‚åº¦)
- [ ] å›¢é˜Ÿå¼€å‘æ•ˆç‡æå‡ 15%

## å…³é”®å†³ç­–æ€»ç»“

### å·¥å…·ç®¡ç†æƒå¨åˆ†é…
âœ… **æ‰€æœ‰MCPæœåŠ¡å™¨æ³¨å†Œå’Œç®¡ç†ç»Ÿä¸€æ”¾åœ¨ToolScoreä¸­**
- åŒ…æ‹¬é¢„ç½®çš„MCPæœåŠ¡å™¨(python_executor_server, browser_navigator_server)
- åŒ…æ‹¬åŠ¨æ€å®‰è£…çš„MCPæœåŠ¡å™¨
- åŒ…æ‹¬å·¥å…·å‘ç°ã€å®‰è£…ã€ç”Ÿå‘½å‘¨æœŸç®¡ç†çš„æ‰€æœ‰é€»è¾‘

### Enhanced Reasoning Runtimeå®šä½
âœ… **è½¬æ¢ä¸ºçº¯ç²¹çš„LLMæ¨ç†å’Œæ‰§è¡Œå¼•æ“**
- ä¸“æ³¨LLMæ¨ç†ã€ä»»åŠ¡åˆ†è§£ã€è½¨è¿¹ç®¡ç†
- é€šè¿‡ç®€å•çš„HTTP APIä»ToolScoreè·å–å·¥å…·ä¿¡æ¯
- ç›´æ¥è°ƒç”¨MCPæœåŠ¡å™¨æ‰§è¡Œå·¥å…·ï¼Œæ— éœ€å¤æ‚çš„ä¸­é—´å±‚

### ä¼˜åŒ–çš„å·¥ä½œæµç¨‹
```
ç”¨æˆ·ä»»åŠ¡ â†’ LLMä»ToolScoreè·å–å·¥å…·åˆ—è¡¨ â†’ LLMæ¨ç†å†³ç­–
    â†“
æœ‰åˆé€‚å·¥å…·ï¼Ÿ
â”œâ”€ æ˜¯ â†’ ç›´æ¥è°ƒç”¨MCPæœåŠ¡å™¨æ‰§è¡Œ
â””â”€ å¦ â†’ è°ƒç”¨ToolScoreå·¥å…·éœ€æ±‚API â†’ è‡ªåŠ¨æœç´¢å®‰è£… â†’ é‡æ–°è·å–å·¥å…·åˆ—è¡¨
```

### æ¶æ„ä¼˜åŠ¿
1. **ç®€åŒ–å¤æ‚æ€§**: æ¶ˆé™¤äº†å¤æ‚çš„å·¥å…·åŒæ­¥æœºåˆ¶ï¼ŒRuntimeå’ŒToolScoreèŒè´£æ¸…æ™°
2. **æå‡æ•ˆç‡**: LLMæ€»æ˜¯èƒ½è·å–æœ€æ–°çš„å·¥å…·ä¿¡æ¯ï¼Œæ— éœ€ç­‰å¾…åŒæ­¥
3. **é™ä½ç»´æŠ¤æˆæœ¬**: å·¥å…·ç®¡ç†é€»è¾‘é›†ä¸­åœ¨ToolScoreï¼Œå‡å°‘ä»£ç é‡å¤
4. **æé«˜æ‰©å±•æ€§**: æ–°å¢Runtimeæ— éœ€é‡æ–°å®ç°å·¥å…·ç®¡ç†åŠŸèƒ½

### å®æ–½å»ºè®®
æœ¬æ–¹æ¡ˆåŸºäºæ‚¨çš„å®é™…éœ€æ±‚å’Œå·¥ä½œæµç¨‹è®¾è®¡ï¼Œå»ºè®®æŒ‰ç…§4å‘¨çš„æ—¶é—´çº¿å®æ–½ï¼š
1. **Week 1**: ToolScoreæ‰©å±•ä¸ºå®Œæ•´å·¥å…·ç®¡ç†ä¸­å¿ƒ
2. **Week 2**: Enhanced Reasoning Runtimeå¤§å¹…ç®€åŒ–
3. **Week 3**: å…¨é¢æµ‹è¯•éªŒè¯
4. **Week 4**: éƒ¨ç½²ä¸Šçº¿å’Œç›‘æ§

è¿™æ ·çš„æ¶æ„æ›´åŠ ç¬¦åˆå•ä¸€èŒè´£åŸåˆ™ï¼Œå°†æ˜¾è‘—æå‡ç³»ç»Ÿçš„å¯ç»´æŠ¤æ€§å’Œæ€§èƒ½ã€‚

## MCPæœåŠ¡å™¨æŒä¹…åŒ–ä¸åŠ¨æ€æ³¨å†Œä¼˜åŒ–æ–¹æ¡ˆ

### é—®é¢˜åˆ†æ

#### å½“å‰å­˜åœ¨çš„é—®é¢˜
1. **å®¹å™¨é‡å¯ä¸¢å¤±**: åŠ¨æ€å®‰è£…çš„MCPæœåŠ¡å™¨å®¹å™¨åœ¨ç³»ç»Ÿé‡å¯åä¼šæ¶ˆå¤±
2. **æ¢å¤æœºåˆ¶ä¸å®Œå–„**: è™½ç„¶é…ç½®å­˜å‚¨åœ¨Redisä¸­ï¼Œä½†ç¼ºä¹è‡ªåŠ¨é‡æ–°å®‰è£…æœºåˆ¶
3. **æ³¨å†Œå»¶è¿Ÿ**: åŠ¨æ€æ³¨å†Œåæ˜¯å¦èƒ½ç«‹å³ä½¿ç”¨å­˜åœ¨ä¸ç¡®å®šæ€§
4. **èµ„æºæµªè´¹**: é‡å¤ä¸‹è½½å’Œå®‰è£…ç›¸åŒçš„MCPæœåŠ¡å™¨

#### å®¹å™¨ç”Ÿå‘½å‘¨æœŸåˆ†æ
```
Dockerå®¹å™¨é‡å¯åœºæ™¯:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç³»ç»Ÿé‡å¯ / Dockeré‡å¯ / å®¹å™¨å´©æºƒ                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚ é¢„ç½®MCPæœåŠ¡å™¨ (åœ¨docker-compose.ymlä¸­)             â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ python-executor-server:8081  âœ… è‡ªåŠ¨é‡å¯        â”‚â”‚
â”‚  â”‚ â””â”€â”€ browser-navigator-server:8082 âœ… è‡ªåŠ¨é‡å¯        â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚ åŠ¨æ€å®‰è£…çš„MCPæœåŠ¡å™¨                                 â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ container_id: abc123 âŒ å®¹å™¨æ¶ˆå¤±                â”‚â”‚
â”‚  â”‚ â”œâ”€â”€ ç«¯å£8100-8200     âŒ é‡Šæ”¾                       â”‚â”‚
â”‚  â”‚ â””â”€â”€ é…ç½®åœ¨Redis       âœ… ä¿å­˜                       â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### è§£å†³æ–¹æ¡ˆè®¾è®¡

#### æ–¹æ¡ˆ1: å®Œå…¨æŒä¹…åŒ–æ–¹æ¡ˆ (æ¨è)

##### 1.1 Docker Imageæœ¬åœ°ç¼“å­˜æœºåˆ¶
```python
# æ–°å¢: core/toolscore/mcp_image_manager.py
class MCPImageManager:
    """MCP Dockeré•œåƒç®¡ç†å™¨ - å®ç°æœ¬åœ°æŒä¹…åŒ–ç¼“å­˜"""
    
    def __init__(self):
        self.local_image_cache = "/app/mcp_images"  # æŒ‚è½½çš„æŒä¹…åŒ–ç›®å½•
        self.docker_client = docker.from_env()
        
    async def cache_mcp_image(self, candidate: MCPServerCandidate) -> str:
        """ä¸‹è½½å¹¶ç¼“å­˜MCPæœåŠ¡å™¨é•œåƒåˆ°æœ¬åœ°"""
        image_name = f"mcp-{candidate.name.lower().replace(' ', '-')}"
        cache_path = Path(self.local_image_cache) / f"{image_name}.tar"
        
        try:
            # æ£€æŸ¥æ˜¯å¦å·²ç¼“å­˜
            if cache_path.exists():
                logger.info(f"Found cached image: {cache_path}")
                return await self._load_cached_image(cache_path, image_name)
            
            # æ„å»ºæ–°é•œåƒ
            built_image = await self._build_mcp_image(candidate, image_name)
            
            # ä¿å­˜åˆ°æœ¬åœ°ç¼“å­˜
            await self._save_image_to_cache(built_image, cache_path)
            
            return built_image.id
            
        except Exception as e:
            logger.error(f"Failed to cache MCP image: {e}")
            raise
    
    async def _save_image_to_cache(self, image, cache_path: Path):
        """ä¿å­˜Dockeré•œåƒåˆ°æœ¬åœ°æ–‡ä»¶"""
        cache_path.parent.mkdir(parents=True, exist_ok=True)
        
        # å°†é•œåƒä¿å­˜ä¸ºtaræ–‡ä»¶
        with open(cache_path, 'wb') as f:
            for chunk in image.save():
                f.write(chunk)
        
        logger.info(f"Cached image to: {cache_path}")
    
    async def _load_cached_image(self, cache_path: Path, image_name: str) -> str:
        """ä»ç¼“å­˜åŠ è½½Dockeré•œåƒ"""
        with open(cache_path, 'rb') as f:
            images = self.docker_client.images.load(f.read())
            
        # ä¸ºé•œåƒæ·»åŠ æ ‡ç­¾
        for image in images:
            image.tag(image_name, "latest")
            return image.id
```

##### 1.2 æŒä¹…åŒ–å®¹å™¨ç®¡ç†
```python
# å¢å¼º: core/toolscore/persistent_container_manager.py
class PersistentContainerManager:
    """æŒä¹…åŒ–å®¹å™¨ç®¡ç†å™¨ - ç¡®ä¿å®¹å™¨åœ¨é‡å¯åè‡ªåŠ¨æ¢å¤"""
    
    def __init__(self):
        self.restart_policy = {"Name": "unless-stopped"}  # å®¹å™¨é‡å¯ç­–ç•¥
        self.persistent_volumes = {}  # æŒä¹…åŒ–å·æ˜ å°„
        
    async def create_persistent_container(self, 
                                        image_id: str, 
                                        server_spec: MCPServerSpec,
                                        port: int) -> str:
        """åˆ›å»ºæŒä¹…åŒ–å®¹å™¨ï¼Œç¡®ä¿é‡å¯åè‡ªåŠ¨æ¢å¤"""
        
        container_name = f"mcp-{server_spec.tool_id}"
        
        # å®¹å™¨é…ç½®
        container_config = {
            "image": image_id,
            "name": container_name,
            "ports": {f"{port}/tcp": port},
            "environment": {
                "MCP_SERVER_PORT": str(port),
                "TOOLSCORE_ENDPOINT": "ws://toolscore:8080/websocket"
            },
            "restart_policy": self.restart_policy,
            "network_mode": "agent-data-platform_agent_network",
            "labels": {
                "mcp.server.id": server_spec.tool_id,
                "mcp.server.name": server_spec.name,
                "mcp.manager": "toolscore",
                "mcp.auto-recover": "true"
            }
        }
        
        # åˆ›å»ºæŒä¹…åŒ–å·(å¦‚æœéœ€è¦)
        if server_spec.server_config.get("requires_persistence"):
            volume_name = f"mcp-{server_spec.tool_id}-data"
            container_config["volumes"] = {
                volume_name: {"bind": "/data", "mode": "rw"}
            }
        
        try:
            container = self.docker_client.containers.run(
                detach=True,
                **container_config
            )
            
            logger.info(f"Created persistent container: {container.name} ({container.id[:12]})")
            return container.id
            
        except Exception as e:
            logger.error(f"Failed to create persistent container: {e}")
            raise
    
    async def recover_all_containers(self):
        """æ¢å¤æ‰€æœ‰æ ‡è®°ä¸ºè‡ªåŠ¨æ¢å¤çš„å®¹å™¨"""
        try:
            # æŸ¥æ‰¾æ‰€æœ‰MCPå®¹å™¨
            containers = self.docker_client.containers.list(
                all=True,
                filters={"label": "mcp.auto-recover=true"}
            )
            
            recovered_count = 0
            for container in containers:
                try:
                    if container.status != 'running':
                        container.start()
                        logger.info(f"Recovered container: {container.name}")
                        recovered_count += 1
                    else:
                        logger.debug(f"Container already running: {container.name}")
                        
                except Exception as e:
                    logger.error(f"Failed to recover container {container.name}: {e}")
                    continue
            
            logger.info(f"Recovered {recovered_count} MCP containers")
            return recovered_count
            
        except Exception as e:
            logger.error(f"Failed to recover containers: {e}")
            return 0
```

##### 1.3 å¯åŠ¨æ—¶è‡ªåŠ¨æ¢å¤æœºåˆ¶
```python
# å¢å¼º: core/toolscore/dynamic_mcp_manager.py
class DynamicMCPManager:
    def __init__(self):
        # ... ç°æœ‰ä»£ç  ...
        self.image_manager = MCPImageManager()
        self.container_manager = PersistentContainerManager()
    
    async def initialize(self):
        """åˆå§‹åŒ–æ—¶è‡ªåŠ¨æ¢å¤æ‰€æœ‰MCPæœåŠ¡å™¨"""
        # ... ç°æœ‰åˆå§‹åŒ–ä»£ç  ...
        
        # 1. æ¢å¤Dockerå®¹å™¨
        await self.container_manager.recover_all_containers()
        
        # 2. æ¢å¤æœåŠ¡æ³¨å†Œ
        await self._restore_persistent_servers_enhanced()
    
    async def _restore_persistent_servers_enhanced(self):
        """å¢å¼ºç‰ˆæŒä¹…åŒ–æœåŠ¡å™¨æ¢å¤"""
        try:
            stored_servers = await self.persistent_storage.load_all_mcp_servers()
            
            for server_info in stored_servers:
                server_data = server_info["server_data"]
                install_result_data = server_info.get("install_result")
                
                try:
                    # é‡å»ºæœåŠ¡å™¨è§„æ ¼
                    server_spec = await self._rebuild_server_spec(server_data)
                    
                    # æ£€æŸ¥å®¹å™¨çŠ¶æ€
                    container_status = await self._check_container_status(
                        install_result_data.get("container_id")
                    )
                    
                    if container_status == "running":
                        # å®¹å™¨è¿è¡Œä¸­ï¼Œç›´æ¥é‡æ–°æ³¨å†Œ
                        await self._reregister_running_server(server_spec, install_result_data)
                        
                    elif container_status == "stopped":
                        # å®¹å™¨å­˜åœ¨ä½†åœæ­¢ï¼Œå¯åŠ¨å®ƒ
                        await self._restart_stopped_container(server_spec, install_result_data)
                        
                    else:
                        # å®¹å™¨ä¸å­˜åœ¨ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰ç¼“å­˜çš„é•œåƒ
                        await self._restore_from_cached_image(server_spec, install_result_data)
                        
                except Exception as e:
                    logger.error(f"Failed to restore server {server_data['name']}: {e}")
                    # è®°å½•å¤±è´¥ä½†ç»§ç»­å¤„ç†å…¶ä»–æœåŠ¡å™¨
                    continue
            
        except Exception as e:
            logger.error(f"Failed to restore persistent servers: {e}")
    
    async def _check_container_status(self, container_id: str) -> str:
        """æ£€æŸ¥å®¹å™¨çŠ¶æ€"""
        if not container_id:
            return "not_found"
            
        try:
            container = self.docker_client.containers.get(container_id)
            return container.status
        except docker.errors.NotFound:
            return "not_found"
        except Exception as e:
            logger.error(f"Error checking container {container_id}: {e}")
            return "error"
    
    async def _restore_from_cached_image(self, server_spec: MCPServerSpec, install_result_data: dict):
        """ä»ç¼“å­˜çš„é•œåƒæ¢å¤æœåŠ¡å™¨"""
        try:
            # æ£€æŸ¥æ˜¯å¦æœ‰ç¼“å­˜çš„é•œåƒ
            image_exists = await self.image_manager.check_cached_image(server_spec.tool_id)
            
            if image_exists:
                # ä½¿ç”¨ç¼“å­˜çš„é•œåƒé‡æ–°åˆ›å»ºå®¹å™¨
                port = install_result_data.get("port") or self._allocate_port()
                container_id = await self.container_manager.create_persistent_container(
                    image_exists, server_spec, port
                )
                
                # æ›´æ–°å®‰è£…ç»“æœ
                new_install_result = InstallationResult(
                    success=True,
                    server_id=server_spec.tool_id,
                    endpoint=f"ws://localhost:{port}/mcp",
                    container_id=container_id,
                    port=port
                )
                
                # é‡æ–°æ³¨å†Œåˆ°å·¥å…·åº“
                await self._reregister_server(server_spec, new_install_result)
                
                logger.info(f"Successfully restored {server_spec.name} from cached image")
                
            else:
                logger.warning(f"No cached image found for {server_spec.name}, will reinstall on demand")
                
        except Exception as e:
            logger.error(f"Failed to restore from cached image: {e}")
```

#### æ–¹æ¡ˆ2: å³æ—¶å¯ç”¨çš„åŠ¨æ€æ³¨å†Œæœºåˆ¶

##### 2.1 å®æ—¶å·¥å…·æ³¨å†Œä¸é€šçŸ¥
```python
# å¢å¼º: core/toolscore/real_time_registry.py
class RealTimeToolRegistry:
    """å®æ—¶å·¥å…·æ³¨å†Œå™¨ - ç¡®ä¿æ³¨å†Œåç«‹å³å¯ç”¨"""
    
    def __init__(self):
        self.redis_client = None
        self.websocket_connections = set()  # è¿æ¥çš„å®¢æˆ·ç«¯
        
    async def register_tool_immediately(self, server_spec: MCPServerSpec, install_result: InstallationResult):
        """ç«‹å³æ³¨å†Œå·¥å…·å¹¶é€šçŸ¥æ‰€æœ‰å®¢æˆ·ç«¯"""
        try:
            # 1. ç«‹å³æ³¨å†Œåˆ°å·¥å…·åº“
            registration_result = await self.tool_library.register_mcp_server(server_spec)
            
            if registration_result.success:
                # 2. ç«‹å³å‘å¸ƒRedisäº‹ä»¶
                await self._publish_tool_available_event(server_spec, install_result)
                
                # 3. ç«‹å³é€šè¿‡WebSocketé€šçŸ¥æ‰€æœ‰è¿æ¥çš„å®¢æˆ·ç«¯
                await self._notify_clients_immediately(server_spec, install_result)
                
                # 4. æ›´æ–°æœ¬åœ°ç¼“å­˜
                await self._update_local_cache(server_spec)
                
                logger.info(f"Tool {server_spec.tool_id} is immediately available!")
                return True
            else:
                logger.error(f"Failed to register tool: {registration_result.error}")
                return False
                
        except Exception as e:
            logger.error(f"Failed immediate registration: {e}")
            return False
    
    async def _publish_tool_available_event(self, server_spec: MCPServerSpec, install_result: InstallationResult):
        """å‘å¸ƒå·¥å…·å¯ç”¨äº‹ä»¶"""
        event_data = {
            "event_type": "tool_available",
            "tool_id": server_spec.tool_id,
            "tool_spec": {
                "tool_id": server_spec.tool_id,
                "name": server_spec.name,
                "description": server_spec.description,
                "capabilities": [cap.name for cap in server_spec.capabilities],
                "endpoint": install_result.endpoint
            },
            "timestamp": time.time(),
            "source": "dynamic_installer"
        }
        
        await self.redis_client.publish('tool_events', json.dumps(event_data))
        await self.redis_client.publish('immediate_tool_updates', json.dumps(event_data))
    
    async def _notify_clients_immediately(self, server_spec: MCPServerSpec, install_result: InstallationResult):
        """ç«‹å³é€šè¿‡WebSocketé€šçŸ¥æ‰€æœ‰å®¢æˆ·ç«¯"""
        notification = {
            "type": "tool_installed",
            "tool_id": server_spec.tool_id,
            "name": server_spec.name,
            "capabilities": [cap.name for cap in server_spec.capabilities],
            "endpoint": install_result.endpoint,
            "status": "ready"
        }
        
        # å‘é€ç»™æ‰€æœ‰è¿æ¥çš„å®¢æˆ·ç«¯
        disconnected_clients = set()
        for websocket in self.websocket_connections:
            try:
                await websocket.send(json.dumps(notification))
            except Exception as e:
                logger.warning(f"Failed to notify client: {e}")
                disconnected_clients.add(websocket)
        
        # æ¸…ç†æ–­å¼€çš„è¿æ¥
        self.websocket_connections -= disconnected_clients
```

##### 2.2 Enhanced Reasoning Runtimeå®æ—¶å“åº”
```python
# æ–°å¢: runtimes/reasoning/real_time_tool_client.py
class RealTimeToolClient:
    """å®æ—¶å·¥å…·å®¢æˆ·ç«¯ - ç«‹å³æ„ŸçŸ¥æ–°å·¥å…·çš„å¯ç”¨æ€§"""
    
    def __init__(self, toolscore_endpoint: str):
        self.endpoint = toolscore_endpoint
        self.websocket = None
        self.available_tools_cache = {}
        self.tool_update_callbacks = []
        
    async def connect_real_time_updates(self):
        """è¿æ¥åˆ°ToolScoreçš„å®æ—¶æ›´æ–°æµ"""
        try:
            self.websocket = await websockets.connect(f"{self.endpoint}/api/v1/events/tools")
            
            # å¯åŠ¨ç›‘å¬ä»»åŠ¡
            asyncio.create_task(self._listen_for_updates())
            
        except Exception as e:
            logger.error(f"Failed to connect to real-time updates: {e}")
    
    async def _listen_for_updates(self):
        """ç›‘å¬å·¥å…·æ›´æ–°äº‹ä»¶"""
        try:
            async for message in self.websocket:
                event = json.loads(message)
                
                if event["type"] == "tool_installed":
                    # ç«‹å³æ›´æ–°æœ¬åœ°ç¼“å­˜
                    self.available_tools_cache[event["tool_id"]] = event
                    
                    # é€šçŸ¥Runtimeæ–°å·¥å…·å¯ç”¨
                    await self._notify_tool_available(event)
                    
                elif event["type"] == "tool_uninstalled":
                    # ç§»é™¤å·¥å…·
                    self.available_tools_cache.pop(event["tool_id"], None)
                    
        except Exception as e:
            logger.error(f"Error listening for updates: {e}")
    
    async def _notify_tool_available(self, tool_event: dict):
        """é€šçŸ¥Runtimeæ–°å·¥å…·ç«‹å³å¯ç”¨"""
        logger.info(f"ğŸ‰ New tool immediately available: {tool_event['name']}")
        
        # å¦‚æœæœ‰ç­‰å¾…çš„ä»»åŠ¡ï¼Œç«‹å³é‡æ–°è¯„ä¼°
        for callback in self.tool_update_callbacks:
            try:
                await callback(tool_event)
            except Exception as e:
                logger.error(f"Error in tool update callback: {e}")
    
    async def get_fresh_tools_for_llm(self) -> str:
        """è·å–æœ€æ–°çš„å·¥å…·åˆ—è¡¨ï¼ŒåŒ…æ‹¬åˆšåˆšå®‰è£…çš„"""
        # åˆå¹¶ç¼“å­˜çš„å·¥å…·å’ŒæœåŠ¡å™¨ç«¯å·¥å…·
        server_tools = await self._fetch_server_tools()
        all_tools = {**self.available_tools_cache, **server_tools}
        
        return self._format_tools_for_llm(all_tools)
    
    async def register_tool_update_callback(self, callback):
        """æ³¨å†Œå·¥å…·æ›´æ–°å›è°ƒ"""
        self.tool_update_callbacks.append(callback)
```

##### 2.3 Enhanced Reasoning Runtimeé›†æˆ
```python
# å¢å¼º: runtimes/reasoning/enhanced_runtime.py
class EnhancedReasoningRuntime:
    def __init__(self):
        # ... ç°æœ‰ä»£ç  ...
        self.real_time_client = RealTimeToolClient("http://toolscore:8090")
        self.pending_tool_requests = {}  # ç­‰å¾…å·¥å…·å®‰è£…çš„ä»»åŠ¡
        
    async def initialize(self):
        # ... ç°æœ‰ä»£ç  ...
        
        # è¿æ¥å®æ—¶æ›´æ–°
        await self.real_time_client.connect_real_time_updates()
        
        # æ³¨å†Œå·¥å…·æ›´æ–°å›è°ƒ
        await self.real_time_client.register_tool_update_callback(
            self._on_new_tool_available
        )
    
    async def _on_new_tool_available(self, tool_event: dict):
        """æ–°å·¥å…·å¯ç”¨æ—¶çš„å›è°ƒ"""
        tool_id = tool_event["tool_id"]
        
        # æ£€æŸ¥æ˜¯å¦æœ‰ç­‰å¾…è¿™ä¸ªå·¥å…·çš„ä»»åŠ¡
        waiting_tasks = []
        for task_id, request_info in list(self.pending_tool_requests.items()):
            if self._tool_matches_requirement(tool_event, request_info["requirements"]):
                waiting_tasks.append(task_id)
                del self.pending_tool_requests[task_id]
        
        # ç«‹å³æ¢å¤ç­‰å¾…çš„ä»»åŠ¡
        for task_id in waiting_tasks:
            logger.info(f"ğŸš€ Resuming task {task_id} with newly available tool {tool_id}")
            # è§¦å‘ä»»åŠ¡æ¢å¤
            await self._resume_task_with_new_tool(task_id, tool_event)
    
    async def execute(self, task: TaskSpec) -> TrajectoryResult:
        """æ”¯æŒå®æ—¶å·¥å…·æ„ŸçŸ¥çš„æ‰§è¡Œæµç¨‹"""
        trajectory = TrajectoryResult(task_id=task.task_id)
        
        while not task_completed:
            # 1. è·å–æœ€æ–°å·¥å…·åˆ—è¡¨ï¼ˆåŒ…æ‹¬åˆšå®‰è£…çš„ï¼‰
            available_tools = await self.real_time_client.get_fresh_tools_for_llm()
            
            # 2. LLMæ¨ç†å†³ç­–
            llm_decision = await self.llm_client.reason_and_decide(
                task_description=task.description,
                available_tools=available_tools,
                previous_steps=trajectory.steps
            )
            
            # 3. æ ¹æ®å†³ç­–æ‰§è¡Œ
            if llm_decision.action_type == "use_existing_tool":
                # ç›´æ¥ä½¿ç”¨å·¥å…·
                result = await self._execute_tool_directly(llm_decision)
                
            elif llm_decision.action_type == "need_new_tool":
                # è¯·æ±‚æ–°å·¥å…·å¹¶ç­‰å¾…
                await self._request_tool_and_wait(task, llm_decision)
                # ç­‰å¾…å®Œæˆåä¼šé€šè¿‡å›è°ƒæ¢å¤æ‰§è¡Œ
                
        return trajectory
    
    async def _request_tool_and_wait(self, task: TaskSpec, llm_decision):
        """è¯·æ±‚æ–°å·¥å…·å¹¶ç­‰å¾…å®‰è£…å®Œæˆ"""
        # è®°å½•ç­‰å¾…çŠ¶æ€
        self.pending_tool_requests[task.task_id] = {
            "requirements": llm_decision.required_capabilities,
            "task": task,
            "decision": llm_decision,
            "timestamp": time.time()
        }
        
        # å‘èµ·å·¥å…·å®‰è£…è¯·æ±‚
        install_result = await self.toolscore_client.request_tool_capability(
            task.description,
            llm_decision.required_capabilities
        )
        
        if install_result["success"]:
            # å®‰è£…æˆåŠŸï¼Œä½†éœ€è¦ç­‰å¾…å®¹å™¨å¯åŠ¨å’Œæ³¨å†Œå®Œæˆ
            # é€šè¿‡å®æ—¶é€šçŸ¥æœºåˆ¶ä¼šè‡ªåŠ¨æ¢å¤ä»»åŠ¡
            logger.info(f"Tool installation initiated for task {task.task_id}")
        else:
            # å®‰è£…å¤±è´¥ï¼Œç§»é™¤ç­‰å¾…è®°å½•
            self.pending_tool_requests.pop(task.task_id, None)
            logger.error(f"Tool installation failed: {install_result.get('message')}")
```

### Docker Composeé…ç½®ä¼˜åŒ–

```yaml
# åœ¨docker-compose.ymlä¸­æ·»åŠ æŒä¹…åŒ–é…ç½®
volumes:
  redis_data:
  mcp_images:      # æ–°å¢: MCPé•œåƒç¼“å­˜
  mcp_containers:  # æ–°å¢: å®¹å™¨æŒä¹…åŒ–æ•°æ®

services:
  toolscore:
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - mcp_images:/app/mcp_images              # MCPé•œåƒç¼“å­˜
      - mcp_containers:/app/mcp_containers      # å®¹å™¨æ•°æ®
    environment:
      - MCP_IMAGE_CACHE_PATH=/app/mcp_images
      - MCP_CONTAINER_DATA_PATH=/app/mcp_containers
      - MCP_AUTO_RECOVERY=true
```

### å…³é”®ç‰¹æ€§æ€»ç»“

#### âœ… **å®Œå…¨æŒä¹…åŒ–**
1. **Dockeré•œåƒç¼“å­˜**: ä¸‹è½½åæ°¸ä¹…ä¿å­˜ï¼Œä¸å—å®¹å™¨é‡å¯å½±å“
2. **å®¹å™¨è‡ªåŠ¨æ¢å¤**: ä½¿ç”¨Dockeré‡å¯ç­–ç•¥ï¼Œç¡®ä¿å®¹å™¨åœ¨ç³»ç»Ÿé‡å¯åè‡ªåŠ¨æ¢å¤
3. **é…ç½®æŒä¹…åŒ–**: Redis + Docker volumesç¡®ä¿é…ç½®æ°¸ä¸ä¸¢å¤±

#### âš¡ **å³æ—¶å¯ç”¨**
1. **å®æ—¶æ³¨å†Œ**: å®‰è£…å®Œæˆåç«‹å³æ³¨å†Œåˆ°å·¥å…·åº“
2. **WebSocketé€šçŸ¥**: ç«‹å³é€šçŸ¥æ‰€æœ‰Runtimeæ–°å·¥å…·å¯ç”¨
3. **æ™ºèƒ½æ¢å¤**: ç­‰å¾…å·¥å…·çš„ä»»åŠ¡è‡ªåŠ¨æ¢å¤æ‰§è¡Œ
4. **é›¶å»¶è¿Ÿæ„ŸçŸ¥**: Runtimeæ— éœ€é‡å¯å³å¯ä½¿ç”¨æ–°å·¥å…·

#### ğŸ¯ **å…·ä½“å®ç°æ•ˆæœ**
- **å®‰è£…ä¸€æ¬¡ï¼Œæ°¸ä¹…å¯ç”¨**: MCPæœåŠ¡å™¨ä¸‹è½½åä¼šæŒä¹…åŒ–ä¿å­˜
- **ç§’çº§å¯ç”¨**: åŠ¨æ€æ³¨å†Œçš„å·¥å…·åœ¨å®‰è£…å®Œæˆåå‡ ç§’å†…å³å¯ä½¿ç”¨
- **è‡ªåŠ¨æ¢å¤**: ç³»ç»Ÿé‡å¯åè‡ªåŠ¨æ¢å¤æ‰€æœ‰å·²å®‰è£…çš„MCPæœåŠ¡å™¨
- **æ— æ„ŸçŸ¥æ›´æ–°**: Runtimeæ— éœ€é‡å¯å³å¯æ„ŸçŸ¥å’Œä½¿ç”¨æ–°å·¥å…·

è¿™ä¸ªä¼˜åŒ–æ–¹æ¡ˆç¡®ä¿äº†MCPæœåŠ¡å™¨çš„å®Œå…¨æŒä¹…åŒ–å’Œå³æ—¶å¯ç”¨æ€§ï¼Œè§£å†³äº†æ‚¨æåˆ°çš„æ‰€æœ‰é—®é¢˜ã€‚

## å®Œæ•´ä»£ç è¿ç§»å’Œä¼˜åŒ–å®æ–½è®¡åˆ’

åŸºäºå½“å‰ä»£ç æ¶æ„åˆ†æï¼Œä»¥ä¸‹æ˜¯è¯¦ç»†çš„ä¸€æ­¥ä¸€æ­¥è¿ç§»å’Œä¼˜åŒ–è®¡åˆ’ï¼š

### ğŸ“‹ å½“å‰ä»£ç çŠ¶æ€åˆ†æ

#### ç°çŠ¶æ€»ç»“
- **Enhanced Reasoning Runtime**: å·²å®ç°å¤æ‚çš„æœ¬åœ°å·¥å…·ç®¡ç†ï¼ˆMCPSearchTool, ToolGapDetector, DynamicMCPManagerï¼‰
- **ToolScore**: åŸºç¡€å·¥å…·æ³¨å†Œä¸­å¿ƒï¼Œç¼ºå°‘å®Œæ•´çš„MCPç®¡ç†åŠŸèƒ½
- **æ¶æ„å†²çª**: åŒé‡å·¥å…·åº“å¯¼è‡´çŠ¶æ€ä¸ä¸€è‡´ï¼ŒåŒæ­¥æœºåˆ¶å¤æ‚
- **æŒä¹…åŒ–é—®é¢˜**: åŠ¨æ€MCPæœåŠ¡å™¨å®¹å™¨é‡å¯åæ¶ˆå¤±ï¼Œç¼ºå°‘å®Œæ•´æ¢å¤æœºåˆ¶

#### éœ€è¦è¿ç§»çš„æ ¸å¿ƒç»„ä»¶
```
Enhanced Runtime â†’ ToolScore
â”œâ”€â”€ mcp_search_tool.py          âœ… å·²å­˜åœ¨ï¼Œéœ€å¢å¼º
â”œâ”€â”€ tool_gap_detector.py        âœ… å·²å­˜åœ¨ï¼Œéœ€è¿ç§»
â”œâ”€â”€ dynamic_mcp_manager.py      âœ… å·²å­˜åœ¨ï¼Œéœ€å¢å¼ºæŒä¹…åŒ–
â””â”€â”€ å¤æ‚çš„åŒæ­¥é€»è¾‘              âŒ éœ€å®Œå…¨ç§»é™¤
```

### ğŸ¯ **é˜¶æ®µ1: ToolScoreæ‰©å±•ä¸ºå®Œæ•´å·¥å…·ç®¡ç†ä¸­å¿ƒ (Week 1)**

#### Step 1.1: æ–°å¢MCPæŒä¹…åŒ–ç»„ä»¶
åˆ›å»ºä»¥ä¸‹æ–°æ–‡ä»¶ä»¥å®ç°å®Œå…¨æŒä¹…åŒ–ï¼š

```bash
# æ–°æ–‡ä»¶1: MCPé•œåƒç®¡ç†å™¨
touch core/toolscore/mcp_image_manager.py

# æ–°æ–‡ä»¶2: æŒä¹…åŒ–å®¹å™¨ç®¡ç†å™¨  
touch core/toolscore/persistent_container_manager.py

# æ–°æ–‡ä»¶3: å®æ—¶å·¥å…·æ³¨å†Œå™¨
touch core/toolscore/real_time_registry.py

# æ–°æ–‡ä»¶4: ç¼“å­˜ç®¡ç†å™¨
touch core/toolscore/mcp_cache_manager.py

# æ–°æ–‡ä»¶5: å·¥å…·å‘ç°APIå±‚
touch core/toolscore/tool_discovery_api.py
```

#### Step 1.2: è¿ç§»å·¥å…·ç¼ºå£æ£€æµ‹å™¨åˆ°ToolScore
å°†`core/toolscore/tool_gap_detector.py`ä»Runtimeä¾èµ–ä¸­è§£è€¦ï¼š

```python
# ğŸ”„ ä¿®æ”¹æ–‡ä»¶: core/toolscore/tool_gap_detector.py
# å½“å‰é—®é¢˜: ä¾èµ–Enhanced Runtimeçš„LLMå®¢æˆ·ç«¯
# è§£å†³æ–¹æ¡ˆ: æ”¹ä¸ºä¾èµ–ToolScoreçš„ç‹¬ç«‹LLMå®¢æˆ·ç«¯
class ToolGapDetector:
    def __init__(self, llm_endpoint: str = None):
        # ä»ä¾èµ–Runtimeçš„LLMå®¢æˆ·ç«¯æ”¹ä¸ºç‹¬ç«‹åˆå§‹åŒ–
        self.llm_client = self._create_independent_llm_client(llm_endpoint)
```

#### Step 1.3: å¢å¼ºåŠ¨æ€MCPç®¡ç†å™¨
ä¿®æ”¹`core/toolscore/dynamic_mcp_manager.py`ï¼Œæ·»åŠ æŒä¹…åŒ–åŠŸèƒ½ï¼š

```python
# ğŸ”„ ä¿®æ”¹æ–‡ä»¶: core/toolscore/dynamic_mcp_manager.py  
class DynamicMCPManager:
    def __init__(self):
        # æ·»åŠ æ–°ç»„ä»¶
        self.image_manager = MCPImageManager()           # æ–°å¢
        self.container_manager = PersistentContainerManager()  # æ–°å¢
        self.real_time_registry = RealTimeToolRegistry()      # æ–°å¢
        
    async def initialize(self):
        # å¢å¼ºåˆå§‹åŒ–æµç¨‹
        await self.container_manager.recover_all_containers()
        await self._restore_persistent_servers_enhanced()
```

#### Step 1.4: æ–°å¢ToolScore APIç«¯ç‚¹
ä¿®æ”¹`core/toolscore/monitoring_api.py`ï¼Œæ·»åŠ LLMå·¥ä½œæµç¨‹ä¸“ç”¨APIï¼š

```python
# ğŸ”„ ä¿®æ”¹æ–‡ä»¶: core/toolscore/monitoring_api.py
@app.get("/api/v1/tools/available")
async def get_available_tools_for_llm():
    """è¿”å›æ ¼å¼åŒ–çš„å·¥å…·åˆ—è¡¨ï¼Œä¸“é—¨ä¸ºLLMå†³ç­–è®¾è®¡"""
    pass

@app.post("/api/v1/tools/request-capability") 
async def request_tool_capability():
    """ä¸€ç«™å¼å·¥å…·è·å–æœåŠ¡ - LLMå‘ç°ç¼ºå°‘å·¥å…·æ—¶è°ƒç”¨"""
    pass

@app.websocket("/api/v1/events/tools")
async def tools_event_stream():
    """å®æ—¶å·¥å…·å˜æ›´é€šçŸ¥"""
    pass
```

### ğŸ¯ **é˜¶æ®µ2: Enhanced Reasoning Runtimeç®€åŒ–é‡æ„ (Week 2)**

#### Step 2.1: ç§»é™¤å¤æ‚çš„å·¥å…·ç®¡ç†ç»„ä»¶
ä¿®æ”¹`runtimes/reasoning/enhanced_runtime.py`ï¼Œå¤§å¹…ç®€åŒ–ï¼š

```python
# ğŸ”„ ä¿®æ”¹æ–‡ä»¶: runtimes/reasoning/enhanced_runtime.py
class EnhancedReasoningRuntime:
    def __init__(self):
        # âŒ ç§»é™¤è¿™äº›ç»„ä»¶:
        # self.tool_sync_manager = None
        # self.execution_coordinator = None  
        # self.dynamic_mcp_manager = None
        # self.tool_gap_detector = None
        # self.mcp_search_tool = None
        
        # âœ… æ–°å¢è½»é‡çº§å®¢æˆ·ç«¯:
        self.toolscore_client = ToolScoreClient("http://toolscore:8090")
        self.real_time_client = RealTimeToolClient("http://toolscore:8090")
```

#### Step 2.2: åˆ›å»ºè½»é‡çº§ToolScoreå®¢æˆ·ç«¯
æ–°å»ºæ–‡ä»¶å®ç°ç®€åŒ–çš„APIè°ƒç”¨ï¼š

```bash
# æ–°æ–‡ä»¶: Runtimeä¸“ç”¨çš„è½»é‡çº§å®¢æˆ·ç«¯
touch runtimes/reasoning/toolscore_client.py
touch runtimes/reasoning/real_time_tool_client.py
```

#### Step 2.3: é‡æ„æ‰§è¡Œæµç¨‹
ç®€åŒ–`execute()`æ–¹æ³•ï¼Œä½¿ç”¨ToolScore APIï¼š

```python
# ğŸ”„ ä¿®æ”¹æ–‡ä»¶: runtimes/reasoning/enhanced_runtime.py  
async def execute(self, task: TaskSpec) -> TrajectoryResult:
    while not task_completed:
        # 1. ä»ToolScoreè·å–æœ€æ–°å·¥å…·åˆ—è¡¨
        available_tools = await self.toolscore_client.get_available_tools_for_llm()
        
        # 2. LLMæ¨ç†å†³ç­–
        llm_decision = await self.llm_client.reason_and_decide(...)
        
        # 3. æ ¹æ®å†³ç­–æ‰§è¡Œ
        if llm_decision.action_type == "use_existing_tool":
            result = await self._execute_tool_directly(llm_decision)
        elif llm_decision.action_type == "need_new_tool":  
            await self._request_tool_capability(task, llm_decision)
```

### ğŸ¯ **é˜¶æ®µ3: æŒä¹…åŒ–æœºåˆ¶å®æ–½ (Week 3)**

#### Step 3.1: Docker Composeé…ç½®æ›´æ–°
ä¿®æ”¹`docker-compose.yml`æ·»åŠ æŒä¹…åŒ–å·ï¼š

```yaml
# ğŸ”„ ä¿®æ”¹æ–‡ä»¶: docker-compose.yml
volumes:
  redis_data:
  mcp_images:      # æ–°å¢: MCPé•œåƒç¼“å­˜
  mcp_containers:  # æ–°å¢: å®¹å™¨æ•°æ®

services:
  toolscore:
    volumes:
      - mcp_images:/app/mcp_images
      - mcp_containers:/app/mcp_containers
    environment:
      - MCP_AUTO_RECOVERY=true
```

#### Step 3.2: å®ç°é•œåƒç¼“å­˜æœºåˆ¶
ç¼–å†™`core/toolscore/mcp_image_manager.py`ï¼š

```python
# âœ… æ–°å»ºæ–‡ä»¶: core/toolscore/mcp_image_manager.py
class MCPImageManager:
    async def cache_mcp_image(self, candidate: MCPServerCandidate) -> str:
        # æ£€æŸ¥æœ¬åœ°ç¼“å­˜
        # æ„å»ºå¹¶ä¿å­˜é•œåƒ  
        # è¿”å›é•œåƒID
```

#### Step 3.3: å®ç°å®¹å™¨æŒä¹…åŒ–
ç¼–å†™`core/toolscore/persistent_container_manager.py`ï¼š

```python
# âœ… æ–°å»ºæ–‡ä»¶: core/toolscore/persistent_container_manager.py  
class PersistentContainerManager:
    async def create_persistent_container(self, image_id, server_spec, port):
        # ä½¿ç”¨Dockeré‡å¯ç­–ç•¥åˆ›å»ºå®¹å™¨
        # æ·»åŠ è‡ªåŠ¨æ¢å¤æ ‡ç­¾
        # é…ç½®æŒä¹…åŒ–å·
```

### ğŸ¯ **é˜¶æ®µ4: å®æ—¶æ³¨å†Œæœºåˆ¶ (Week 4)**

#### Step 4.1: å®ç°å®æ—¶å·¥å…·æ³¨å†Œ
ç¼–å†™`core/toolscore/real_time_registry.py`ï¼š

```python
# âœ… æ–°å»ºæ–‡ä»¶: core/toolscore/real_time_registry.py
class RealTimeToolRegistry:
    async def register_tool_immediately(self, server_spec, install_result):
        # ç«‹å³æ³¨å†Œåˆ°å·¥å…·åº“
        # å‘å¸ƒRedisäº‹ä»¶
        # WebSocketé€šçŸ¥æ‰€æœ‰å®¢æˆ·ç«¯
        # æ›´æ–°æœ¬åœ°ç¼“å­˜
```

#### Step 4.2: Runtimeå®æ—¶å“åº”
ç¼–å†™`runtimes/reasoning/real_time_tool_client.py`ï¼š

```python
# âœ… æ–°å»ºæ–‡ä»¶: runtimes/reasoning/real_time_tool_client.py
class RealTimeToolClient:
    async def connect_real_time_updates(self):
        # è¿æ¥WebSocketæ›´æ–°æµ
        # ç›‘å¬å·¥å…·å˜æ›´äº‹ä»¶
        # ç«‹å³æ›´æ–°æœ¬åœ°ç¼“å­˜
        # æ¢å¤ç­‰å¾…çš„ä»»åŠ¡
```

### ğŸ“ **å…·ä½“æ–‡ä»¶ä¿®æ”¹æ¸…å•**

#### ğŸ”„ éœ€è¦ä¿®æ”¹çš„ç°æœ‰æ–‡ä»¶ (12ä¸ª)
1. `core/toolscore/dynamic_mcp_manager.py` - æ·»åŠ æŒä¹…åŒ–åŠŸèƒ½
2. `core/toolscore/tool_gap_detector.py` - è§£è€¦LLMå®¢æˆ·ç«¯ä¾èµ–
3. `core/toolscore/mcp_search_tool.py` - å¢å¼ºé›†ä¸­å¼ç®¡ç†
4. `core/toolscore/monitoring_api.py` - æ·»åŠ æ–°APIç«¯ç‚¹
5. `core/toolscore/unified_tool_library.py` - é›†æˆæ–°ç®¡ç†å™¨
6. `runtimes/reasoning/enhanced_runtime.py` - å¤§å¹…ç®€åŒ–é‡æ„
7. `docker-compose.yml` - æ·»åŠ æŒä¹…åŒ–å·é…ç½®
8. `docker/toolscore.Dockerfile` - ç¯å¢ƒå˜é‡æ›´æ–°
9. `docker/enhanced_reasoning.Dockerfile` - ç®€åŒ–ä¾èµ–
10. `core/toolscore/persistent_storage.py` - å¢å¼ºæŒä¹…åŒ–ç­–ç•¥
11. `requirements.txt` - å¯èƒ½éœ€è¦æ–°ä¾èµ–
12. `scripts/start.sh` - å¯åŠ¨è„šæœ¬ä¼˜åŒ–

#### âœ… éœ€è¦æ–°å»ºçš„æ–‡ä»¶ (7ä¸ª)
1. `core/toolscore/mcp_image_manager.py` - Dockeré•œåƒç¼“å­˜ç®¡ç†
2. `core/toolscore/persistent_container_manager.py` - æŒä¹…åŒ–å®¹å™¨ç®¡ç†
3. `core/toolscore/real_time_registry.py` - å®æ—¶å·¥å…·æ³¨å†Œ
4. `core/toolscore/mcp_cache_manager.py` - ç»Ÿä¸€ç¼“å­˜ç®¡ç†
5. `core/toolscore/tool_discovery_api.py` - å·¥å…·å‘ç°APIå±‚
6. `runtimes/reasoning/toolscore_client.py` - ToolScoreè½»é‡çº§å®¢æˆ·ç«¯
7. `runtimes/reasoning/real_time_tool_client.py` - å®æ—¶å·¥å…·å®¢æˆ·ç«¯

### âš¡ **å…³é”®ä¼˜åŒ–æ•ˆæœ**

#### è§£å†³çš„æ ¸å¿ƒé—®é¢˜
1. **âœ… å®Œå…¨æŒä¹…åŒ–**: MCPæœåŠ¡å™¨å®‰è£…ä¸€æ¬¡ï¼Œæ°¸ä¹…å¯ç”¨
2. **âœ… å³æ—¶å¯ç”¨**: åŠ¨æ€æ³¨å†Œåå‡ ç§’å†…å¯ä½¿ç”¨ï¼Œæ— éœ€é‡å¯
3. **âœ… è‡ªåŠ¨æ¢å¤**: ç³»ç»Ÿé‡å¯åè‡ªåŠ¨æ¢å¤æ‰€æœ‰å·²å®‰è£…æœåŠ¡å™¨
4. **âœ… æ¶æ„ç®€åŒ–**: æ¶ˆé™¤åŒé‡å·¥å…·åº“ï¼ŒèŒè´£æ¸…æ™°
5. **âœ… æ€§èƒ½ä¼˜åŒ–**: ç»Ÿä¸€ç¼“å­˜ï¼Œå‡å°‘é‡å¤APIè°ƒç”¨

#### å®æ–½åçš„å·¥ä½œæµç¨‹
```
ç”¨æˆ·ä»»åŠ¡ â†’ Runtimeä»ToolScoreè·å–å·¥å…·åˆ—è¡¨ â†’ LLMæ¨ç†å†³ç­–
    â†“
æœ‰åˆé€‚å·¥å…·ï¼Ÿ
â”œâ”€ æ˜¯ â†’ ç›´æ¥è°ƒç”¨MCPæœåŠ¡å™¨æ‰§è¡Œ  
â””â”€ å¦ â†’ è°ƒç”¨ToolScoreå·¥å…·éœ€æ±‚API â†’ è‡ªåŠ¨æœç´¢å®‰è£… â†’ WebSocketé€šçŸ¥ â†’ ç«‹å³å¯ç”¨
```

### ğŸš€ **å¼€å§‹å®æ–½ç¡®è®¤**

ä»¥ä¸Šè®¡åˆ’æ¶µç›–äº†ä»å½“å‰çŠ¶æ€åˆ°ç›®æ ‡æ¶æ„çš„å®Œæ•´è¿ç§»è·¯å¾„ã€‚æ¯ä¸ªé˜¶æ®µéƒ½æœ‰æ˜ç¡®çš„æ–‡ä»¶ä¿®æ”¹æ¸…å•å’Œå®æ–½æ­¥éª¤ã€‚

**è¯·ç¡®è®¤æ˜¯å¦å¼€å§‹æŒ‰æ­¤è®¡åˆ’å®æ–½ä»£ç ä¿®æ”¹ï¼Ÿæˆ‘å»ºè®®ä»é˜¶æ®µ1å¼€å§‹ï¼Œé¦–å…ˆåˆ›å»ºæ–°çš„æŒä¹…åŒ–ç»„ä»¶ã€‚**

## ğŸš§ å®æ–½è¿›åº¦è·Ÿè¸ª

### âœ… **é˜¶æ®µ1 - ToolScoreæ‰©å±•ä¸ºå®Œæ•´å·¥å…·ç®¡ç†ä¸­å¿ƒ - å·²å®Œæˆ 100%**

#### Step 1.1-1.4: æ–°å¢MCPæŒä¹…åŒ–ç»„ä»¶ âœ…
- âœ… `core/toolscore/mcp_image_manager.py` - MCP Dockeré•œåƒç¼“å­˜ç®¡ç†å™¨
  - å®Œæ•´çš„é•œåƒä¸‹è½½ã€æ„å»ºã€ç¼“å­˜åŠŸèƒ½
  - æ”¯æŒä»GitHubå’ŒDocker Hubè·å–é•œåƒ
  - æœ¬åœ°æ–‡ä»¶ç³»ç»ŸæŒä¹…åŒ–å­˜å‚¨
  - è‡ªåŠ¨ç”ŸæˆDockerfileåŠŸèƒ½
  
- âœ… `core/toolscore/persistent_container_manager.py` - æŒä¹…åŒ–å®¹å™¨ç®¡ç†å™¨
  - ä½¿ç”¨Docker `unless-stopped` é‡å¯ç­–ç•¥
  - è‡ªåŠ¨æ¢å¤æ‰€æœ‰MCPå®¹å™¨
  - å®Œæ•´çš„å®¹å™¨ç”Ÿå‘½å‘¨æœŸç®¡ç†
  - æŒä¹…åŒ–å·æ”¯æŒ
  
- âœ… `core/toolscore/real_time_registry.py` - å®æ—¶å·¥å…·æ³¨å†Œå™¨
  - WebSocketå®æ—¶é€šçŸ¥æœºåˆ¶ (ç«¯å£8091)
  - Redis Pub/Subäº‹ä»¶å‘å¸ƒ
  - ç«‹å³æ³¨å†Œå’Œé€šçŸ¥åŠŸèƒ½
  - æœ¬åœ°å·¥å…·ç¼“å­˜ç®¡ç†
  
- âœ… `core/toolscore/mcp_cache_manager.py` - ç»Ÿä¸€ç¼“å­˜ç®¡ç†å™¨
  - å¤šå±‚ç¼“å­˜æ¶æ„ (å†…å­˜ + Redis)
  - ä¸“é—¨çš„GitHub APIã€æœç´¢ç»“æœã€å®‰å…¨éªŒè¯ç¼“å­˜
  - LRUé©±é€ç­–ç•¥å’Œè‡ªåŠ¨æ¸…ç†
  - ç¼“å­˜ç»Ÿè®¡å’Œç›‘æ§

#### Step 1.5: å¢å¼ºåŠ¨æ€MCPç®¡ç†å™¨ âœ…
- âœ… ä¿®æ”¹ `core/toolscore/dynamic_mcp_manager.py`
- âœ… é›†æˆæ–°çš„æŒä¹…åŒ–ç»„ä»¶ï¼ˆé•œåƒç®¡ç†å™¨ã€å®¹å™¨ç®¡ç†å™¨ç­‰ï¼‰
- âœ… å¢å¼ºè‡ªåŠ¨æ¢å¤æœºåˆ¶ (`_restore_single_server_enhanced`)
- âœ… æ·»åŠ å®æ—¶æ³¨å†ŒåŠŸèƒ½ (`_post_install_actions`é›†æˆå®æ—¶æ³¨å†Œ)

#### Step 1.6: æ–°å¢ToolScore APIç«¯ç‚¹ âœ…
- âœ… ä¿®æ”¹ `core/toolscore/monitoring_api.py`
- âœ… æ·»åŠ  `GET /api/v1/tools/available` (ä¸ºLLMä¼˜åŒ–çš„å·¥å…·åˆ—è¡¨)
- âœ… æ·»åŠ  `POST /api/v1/tools/request-capability` (ä¸€ç«™å¼å·¥å…·è·å–æœåŠ¡)
- âœ… æ·»åŠ  `POST /api/v1/tools/analyze-gap` (å·¥å…·ç¼ºå£åˆ†æ)

#### Step 1.7: å·¥å…·ç¼ºå£æ£€æµ‹å™¨è¿ç§»å’Œä¼˜åŒ– âœ…
- âœ… ä¿®æ”¹ `core/toolscore/tool_gap_detector.py`
- âœ… è§£è€¦LLMå®¢æˆ·ç«¯ä¾èµ–ï¼ˆLLMå®¢æˆ·ç«¯å˜ä¸ºå¯é€‰å‚æ•°ï¼‰
- âœ… å®ç°åŸºäºè§„åˆ™çš„å¤‡ç”¨åˆ†æé€»è¾‘ï¼ˆå·²ç§»é™¤ç¡¬ç¼–ç è§„åˆ™ï¼Œå®Œå…¨ä¾èµ–LLMè¯­ä¹‰ç†è§£ï¼‰
- âœ… é›†æˆç¼“å­˜ç®¡ç†å™¨æ”¯æŒ
- âœ… å®Œå–„ç¼“å­˜æ–¹æ³• `cache_analysis_result()` å’Œ `get_analysis_result()`

#### é¢å¤–å®Œæˆå·¥ä½œï¼š
- âœ… **ç§»é™¤ç¡¬ç¼–ç è§„åˆ™**: åˆ é™¤æ‰€æœ‰é¢„å®šä¹‰çš„ä»»åŠ¡ç±»å‹å’Œå…³é”®è¯æ˜ å°„ï¼Œè®©æ¨¡å‹è‡ªä¸»å†³ç­–
- âœ… **æœ¬åœ°JSONä¼˜å…ˆæœç´¢**: ä¿®æ”¹ `search_mcp_servers()` ä¼˜å…ˆä½¿ç”¨æœ¬åœ°JSONæ–‡ä»¶
- âœ… **JSONæ–‡ä»¶ä¼˜åŒ–**: æ¸…ç†317.8MBåˆ°0.8MBï¼Œåˆ é™¤æ‰€æœ‰embeddingå­—æ®µ
- âœ… **é›†æˆç»Ÿä¸€å·¥å…·åº“**: ä¿®æ”¹ `unified_tool_library.py` é›†æˆæ‰€æœ‰æ–°ç»„ä»¶

### âœ… **é˜¶æ®µ2 - Enhanced Reasoning Runtimeç®€åŒ–é‡æ„ - å·²å®Œæˆ 100%**

#### Step 2.1: ç§»é™¤å¤æ‚çš„å·¥å…·ç®¡ç†ç»„ä»¶ âœ…
- âœ… ä¿®æ”¹ `runtimes/reasoning/enhanced_runtime.py`
- âœ… ç§»é™¤ `tool_sync_manager`, `execution_coordinator`, `dynamic_mcp_manager`
- âœ… ç§»é™¤ `tool_gap_detector`, `mcp_search_tool`
- âœ… ç§»é™¤æœ¬åœ° `UnifiedToolLibrary` å®ä¾‹
- âœ… å¤§å¹…ç®€åŒ–å¯¼å…¥å’Œåˆå§‹åŒ–é€»è¾‘

#### Step 2.2: åˆ›å»ºè½»é‡çº§ToolScoreå®¢æˆ·ç«¯ âœ…
- âœ… æ–°å»º `runtimes/reasoning/toolscore_client.py`
  - HTTP APIå®¢æˆ·ç«¯ï¼Œæ”¯æŒå·¥å…·è·å–ã€èƒ½åŠ›è¯·æ±‚ã€ç¼ºå£åˆ†æ
  - å¥åº·æ£€æŸ¥å’Œè¿æ¥ç­‰å¾…æœºåˆ¶
  - å¼‚å¸¸å¤„ç†å’Œé™çº§é€»è¾‘
- âœ… æ–°å»º `runtimes/reasoning/real_time_tool_client.py`
  - WebSocketå®æ—¶ç›‘å¬å·¥å…·å˜æ›´äº‹ä»¶
  - è‡ªåŠ¨é‡è¿æœºåˆ¶å’Œæœ¬åœ°å·¥å…·ç¼“å­˜
  - ç­‰å¾…å·¥å…·è¯·æ±‚ç®¡ç†å’Œå›è°ƒæœºåˆ¶
- âœ… æ›´æ–° `runtimes/reasoning/requirements.txt` æ·»åŠ ä¾èµ–

#### Step 2.3: é‡æ„æ‰§è¡Œæµç¨‹ âœ…
- âœ… å®Œå…¨é‡å†™ `execute()` æ–¹æ³•
- âœ… ä½¿ç”¨ToolScore APIè·å–å·¥å…·åˆ—è¡¨
- âœ… å®ç°å·¥å…·éœ€æ±‚è¯·æ±‚å’Œå®æ—¶å“åº”æœºåˆ¶
- âœ… æ·»åŠ å·¥å…·IDæ˜ å°„å’ŒMCPå®¢æˆ·ç«¯ç›´æ¥è°ƒç”¨
- âœ… ç®€åŒ–é”™è¯¯å¤„ç†å’Œé‡è¯•é€»è¾‘
- âœ… å®ç°cleanupæ–¹æ³•å’Œèµ„æºç®¡ç†

#### é¢å¤–å®Œæˆå·¥ä½œï¼š
- âœ… **å®æ—¶å·¥å…·æ„ŸçŸ¥**: WebSocketç›‘å¬æ–°å·¥å…·å®‰è£…äº‹ä»¶ï¼Œç«‹å³æ›´æ–°å¯ç”¨å·¥å…·åˆ—è¡¨
- âœ… **æ™ºèƒ½å·¥å…·æ˜ å°„**: è‡ªåŠ¨æ˜ å°„å·¥å…·IDåˆ°MCPæœåŠ¡å™¨IDï¼Œæ”¯æŒå¤šç§å‘½åå˜ä½“
- âœ… **é™çº§æœºåˆ¶**: ToolScoreä¸å¯ç”¨æ—¶çš„å¤‡ç”¨å¤„ç†é€»è¾‘
- âœ… **å›è°ƒæœºåˆ¶**: ç­‰å¾…å·¥å…·å®‰è£…å®Œæˆçš„ä»»åŠ¡è‡ªåŠ¨æ¢å¤æœºåˆ¶

### âœ… **é˜¶æ®µ3 - æŒä¹…åŒ–æœºåˆ¶å®æ–½ - å·²å®Œæˆ 100%**

#### Step 3.1: Docker Composeé…ç½®æ›´æ–° âœ…
- âœ… ä¿®æ”¹ `docker-compose.yml` æ·»åŠ æŒä¹…åŒ–å·
- âœ… æ·»åŠ  `mcp_images` å’Œ `mcp_containers` å·
- âœ… æ›´æ–°ç¯å¢ƒå˜é‡é…ç½® (MCP_IMAGE_CACHE_PATH, MCP_AUTO_RECOVERYç­‰)
- âœ… æ·»åŠ WebSocketå®æ—¶é€šçŸ¥ç«¯å£ (8091)

#### Step 3.2: å®¹å™¨åŒ–éªŒè¯å’Œæµ‹è¯• âœ…
- âœ… éªŒè¯æ–°çš„ç®€åŒ–æ¶æ„åœ¨å®¹å™¨ç¯å¢ƒä¸­çš„è¿è¡Œé…ç½®
- âœ… æµ‹è¯•ToolScore APIè°ƒç”¨å’ŒWebSocketè¿æ¥é…ç½®
- âœ… éªŒè¯å·¥å…·å®‰è£…å’Œå®æ—¶é€šçŸ¥æœºåˆ¶é…ç½®
- âœ… åˆ›å»ºå®Œæ•´é›†æˆæµ‹è¯•è„šæœ¬ (`test_complete_integration.py`)

### âœ… **é˜¶æ®µ4 - å®æ—¶æ³¨å†Œæœºåˆ¶å®æ–½ - å·²å®Œæˆ 100%**

#### Step 4.1: WebSocketå®æ—¶å·¥å…·æ³¨å†Œå®ç° âœ…
- âœ… åœ¨ `core/toolscore/monitoring_api.py` ä¸­å®ç° `websocket_tools_events` ç«¯ç‚¹
- âœ… æ·»åŠ  `_handle_websocket_message` æ–¹æ³•å¤„ç†å®¢æˆ·ç«¯æ¶ˆæ¯
- âœ… æ”¯æŒping/pongå¿ƒè·³ã€å·¥å…·åˆ—è¡¨è·å–ã€äº‹ä»¶è®¢é˜…
- âœ… é›†æˆå®æ—¶æ³¨å†Œå™¨çš„WebSocketè¿æ¥ç®¡ç†

#### Step 4.2: Runtimeç«¯å®æ—¶å“åº”å®Œå–„ âœ…
- âœ… `runtimes/reasoning/real_time_tool_client.py` å·²å®Œæ•´å®ç°
- âœ… WebSocketè‡ªåŠ¨é‡è¿æœºåˆ¶å’Œé”™è¯¯å¤„ç†
- âœ… ç­‰å¾…å·¥å…·å®‰è£…çš„ä»»åŠ¡è‡ªåŠ¨æ¢å¤
- âœ… å·¥å…·åŒ¹é…éœ€æ±‚çš„æ™ºèƒ½åˆ¤æ–­é€»è¾‘

#### Step 4.3: ç»„ä»¶é›†æˆå’Œå¼•ç”¨ âœ…
- âœ… ä¿®æ”¹ `unified_tool_library.py` æ·»åŠ  `real_time_registry` å±æ€§å¼•ç”¨
- âœ… ç¡®ä¿APIç«¯ç‚¹èƒ½æ­£ç¡®è®¿é—®å®æ—¶æ³¨å†Œå™¨
- âœ… å®Œå–„WebSocketè¿æ¥ç®¡ç†å’Œäº‹ä»¶å¹¿æ’­

### ğŸ“Š **æ€»ä½“å®Œæˆåº¦**
- **é˜¶æ®µ1**: 100% âœ… (ToolScoreæ‰©å±•)
- **é˜¶æ®µ2**: 100% âœ… (Runtimeç®€åŒ–)
- **é˜¶æ®µ3**: 100% âœ… (æŒä¹…åŒ–æœºåˆ¶)
- **é˜¶æ®µ4**: 100% âœ… (å®æ—¶æ³¨å†Œæœºåˆ¶)
- **æ•´ä½“è¿›åº¦**: 100% (4/4) ğŸ‰