# æ–°ä¸€ä»£å·¥å…·æ³¨å†Œä¸è°ƒç”¨ç³»ç»Ÿå¼€å‘æ–‡æ¡£

**é¡¹ç›®è´Ÿè´£äºº**: æ ¸å¿ƒç ”å‘å›¢é˜Ÿ  
**æ–‡æ¡£ç‰ˆæœ¬**: v3.0  
**åˆ›å»ºæ—¥æœŸ**: 2025-01-17  
**æ›´æ–°æ—¥æœŸ**: 2025-01-17  
**é€‚ç”¨åœºæ™¯**: Datapresso Agent æ•°æ®ç‚¼æ²¹å‚

---

## 1. èƒŒæ™¯ä¸åŠ¨æœº

### 1.1 é¡¹ç›®èƒŒæ™¯

å½“å‰ Datapresso Agent å¹³å°é‡‡ç”¨"ä»»åŠ¡ç”Ÿæˆå™¨ â†’ æ‰§è¡Œæ²™ç›’ â†’ è¯„ä¼°å™¨"ä¸‰å±‚æ¶æ„ï¼Œæ—¨åœ¨æ„å»ºå¯æ„ŸçŸ¥ã€å¯å›æº¯ã€å¯æŒç»­è¿›åŒ–çš„æ™ºèƒ½æ•°æ®å¤„ç†ç³»ç»Ÿã€‚ç„¶è€Œï¼Œéšç€ä¸šåŠ¡å¤æ‚åº¦æå‡å’Œå·¥å…·éœ€æ±‚æ¿€å¢ï¼Œç°æœ‰å·¥å…·è°ƒç”¨æœºåˆ¶æš´éœ²å‡ºä¸¥é‡çš„æ‰©å±•æ€§ç“¶é¢ˆå’Œç»´æŠ¤æˆæœ¬é—®é¢˜ã€‚

### 1.2 æ ¸å¿ƒé—®é¢˜

1. **ç¡¬ç¼–ç å·¥å…·åˆ—è¡¨**: è¿è¡Œæ—¶å›ºå®šå·¥å…·æ¸…å•ï¼Œè¿åDRYåŸåˆ™
2. **ç¡¬ç¼–ç å·¥å…·æè¿°**: LLMæç¤ºä¸­çš„å·¥å…·æè¿°æ‰‹åŠ¨ç»´æŠ¤ï¼ŒåŒæ­¥æˆæœ¬é«˜
3. **ç¡¬ç¼–ç å·¥å…·åˆ†å‘**: if-elifå­—ç¬¦ä¸²åŒ¹é…å·¥å…·è·¯ç”±ï¼Œæ‰©å±•æ€§æå·®
4. **ç¼ºä¹æ‰©å±•æ€§**: æ·»åŠ æ–°å·¥å…·éœ€è¦ä¿®æ”¹å¤šä¸ªæ–‡ä»¶å’Œæ¨¡å—
5. **æ— åŠ¨æ€å‘ç°**: è¿è¡ŒæœŸæ— æ³•æ³¨å†Œæ–°å·¥å…·æˆ–è°ƒæ•´å·¥å…·å¯ç”¨æ€§

### 1.3 è®¾è®¡ç›®æ ‡

1. **ç‹¬ç«‹å·¥å…·ç®¡ç†**: å·¥å…·åº“ä½œä¸ºç‹¬ç«‹æœåŠ¡ï¼Œæä¾›æ³¨å†Œã€å‘ç°ã€ç‰ˆæœ¬ç®¡ç†åŠŸèƒ½
2. **æ™ºèƒ½å·¥å…·å‘ç°**: AgentåŸºäºæ¨ç†è‡ªä¸»è¿›è¡Œåœºæ™¯è¯†åˆ«ã€å·¥å…·åŒ…é€‰æ‹©å’Œå·¥å…·ç­›é€‰
3. **åŒåè®®æ”¯æŒ**: åŒæ—¶æ”¯æŒ Function Toolï¼ˆå†…åµŒï¼‰å’Œ MCP Serverï¼ˆè¿œç¨‹ï¼‰
4. **åŠ¨æ€å·¥å…·åˆ›å»º**: å½“ç°æœ‰å·¥å…·æ— æ³•æ»¡è¶³éœ€æ±‚æ—¶ï¼Œè‡ªåŠ¨æ„å»ºæ–°çš„MCP Server
5. **æ— ç¼è¿ç§»**: ä¿æŒç°æœ‰ API å…¼å®¹æ€§ï¼Œæ”¯æŒæ¸è¿›å¼å‡çº§

---

## 2. ç³»ç»Ÿæ¶æ„æ€»è§ˆ

### 2.1 æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Datapresso Agent Platform                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ§  ä»»åŠ¡ç”Ÿæˆå™¨ (Task Generator)                               â”‚
â”‚     â”œâ”€ è½¨è¿¹åˆ†æå™¨                                            â”‚
â”‚     â”œâ”€ æ¨¡å¼è¯†åˆ«å™¨                                            â”‚
â”‚     â””â”€ ä»»åŠ¡åˆæˆå™¨                                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  âš™ï¸  æ™ºèƒ½æ‰§è¡Œæ²™ç›’ (Intelligent Execution Sandbox)             â”‚
â”‚     â”œâ”€ è‡ªä¸»Agent (å¢å¼ºç‰ˆ)                                   â”‚
â”‚     â”‚   â”œâ”€ åœºæ™¯è¯†åˆ«å™¨                                       â”‚
â”‚     â”‚   â”œâ”€ ä»»åŠ¡åˆ†è§£å™¨                                       â”‚
â”‚     â”‚   â”œâ”€ æ™ºèƒ½å·¥å…·å‘ç°æœåŠ¡ ğŸ†•                               â”‚
â”‚     â”‚   â””â”€ æ‰§è¡Œåè°ƒå™¨                                       â”‚
â”‚     â””â”€ æ‰§è¡Œç¯å¢ƒ                                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ“Š è¯„ä¼°å™¨ (Evaluator)                                       â”‚
â”‚     â”œâ”€ æ‰§è¡Œæ•ˆæœè¯„ä¼°å™¨                                        â”‚
â”‚     â””â”€ è½¨è¿¹åé¦ˆä¼˜åŒ–å™¨                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

          â”Œâ”€ æ ¸å¿ƒåŸºç¡€è®¾æ–½å±‚ â”€â”
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ› ï¸  ç»Ÿä¸€å·¥å…·åº“ (Unified Tool Library) â”‚
â”‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚     å·¥å…·æ³¨å†Œä¸­å¿ƒ                    â”‚ â”‚
â”‚  â”‚  - Function Tool æ³¨å†Œ              â”‚ â”‚
â”‚  â”‚  - MCP Server æ³¨å†Œ                 â”‚ â”‚
â”‚  â”‚  - Toolkit åˆ†ç±»ç®¡ç†                â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   æ™ºèƒ½å‘ç°æœåŠ¡                      â”‚ â”‚
â”‚  â”‚  - æŸ¥è¯¢åˆ†æ                        â”‚ â”‚
â”‚  â”‚  - å·¥å…·åŒ…é€‰æ‹©                      â”‚ â”‚
â”‚  â”‚  - å·¥å…·ç­›é€‰                        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   MCPæ„å»ºå·¥å…· ğŸ†•                   â”‚ â”‚
â”‚  â”‚  - èƒ½åŠ›ç¼ºå£æ£€æµ‹                    â”‚ â”‚
â”‚  â”‚  - è‡ªåŠ¨MCPåˆ›å»º                     â”‚ â”‚
â”‚  â”‚  - ç¯å¢ƒè°ƒç”¨æ¥å£                    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 æ ¸å¿ƒåˆ›æ–°ç‚¹

1. **å»é™¤é¢„å®šä¹‰è§„åˆ™**: å®Œå…¨åŸºäºAgentè‡ªä¸»æ¨ç†ï¼Œæ— ç¡¬ç¼–ç å…³é”®è¯
2. **ä¸‰å±‚é€’è¿›æ¨ç†**: æŸ¥è¯¢åˆ†æ â†’ å·¥å…·åŒ…é€‰æ‹© â†’ å…·ä½“å·¥å…·ç­›é€‰
3. **åŠ¨æ€åœºæ™¯åˆ†ç±»**: Agentå¯åˆ›æ–°æ€§å®šä¹‰æ–°çš„åœºæ™¯ç±»å‹
4. **è‡ªåŠ¨å·¥å…·åˆ›å»º**: å‘ç°èƒ½åŠ›ç¼ºå£æ—¶è‡ªä¸»æ„å»ºæ–°çš„MCP Server
5. **é›†ä½“æ™ºèƒ½è¿›åŒ–**: é€šè¿‡å·¥å…·ä½¿ç”¨åé¦ˆå®ç°æŒç»­ä¼˜åŒ–

---

## 3. æ ¸å¿ƒæ¨¡å—è®¾è®¡

### 3.1 ç»Ÿä¸€å·¥å…·åº“ (UnifiedToolLibrary)

ä½œä¸ºç³»ç»Ÿçš„æ ¸å¿ƒæ¢çº½ï¼Œè´Ÿè´£å·¥å…·çš„æ³¨å†Œã€ç®¡ç†ã€å‘ç°å’Œè°ƒåº¦ã€‚

```python
class UnifiedToolLibrary:
    """ç»Ÿä¸€å·¥å…·åº“ - ç³»ç»Ÿæ ¸å¿ƒæ¢çº½"""
    
    def __init__(self):
        self.tool_registry = ToolRegistry()           # å·¥å…·æ³¨å†Œä¸­å¿ƒ
        self.toolkit_manager = ToolkitManager()       # å·¥å…·åŒ…ç®¡ç†å™¨
        self.discovery_service = IntelligentDiscoveryService()  # æ™ºèƒ½å‘ç°æœåŠ¡
        self.description_engine = DescriptionEngine() # æè¿°å¼•æ“
        self.unified_dispatcher = UnifiedDispatcher() # ç»Ÿä¸€è°ƒåº¦å™¨
        self.mcp_builder = MCPBuilderTool()           # MCPæ„å»ºå·¥å…· ğŸ†•
    
    async def discover_tools(self, user_query: str) -> ToolDiscoveryResult:
        """æ™ºèƒ½å·¥å…·å‘ç° - åŸºäºAgentæ¨ç†"""
        return await self.discovery_service.intelligent_discover(user_query)
    
    async def handle_capability_gap(self, gap: CapabilityGap) -> Optional[Tool]:
        """å¤„ç†èƒ½åŠ›ç¼ºå£ - è‡ªåŠ¨åˆ›å»ºMCP"""
        return await self.mcp_builder.create_mcp_for_gap(gap)
```

### 3.2 æ™ºèƒ½å‘ç°æœåŠ¡ (IntelligentDiscoveryService)

åŸºäºLLMæ¨ç†çš„ä¸‰æ­¥æ™ºèƒ½å·¥å…·å‘ç°æµç¨‹ã€‚

```python
class IntelligentDiscoveryService:
    """æ™ºèƒ½å‘ç°æœåŠ¡ - åŸºäºAgentè‡ªä¸»æ¨ç†"""
    
    async def intelligent_discover(self, user_query: str) -> ToolDiscoveryResult:
        """ä¸‰æ­¥æ™ºèƒ½å‘ç°æµç¨‹"""
        
        # ç¬¬ä¸€æ­¥ï¼šæ™ºèƒ½æŸ¥è¯¢åˆ†æ
        analysis = await self.analyze_query_intelligence(user_query)
        
        # ç¬¬äºŒæ­¥ï¼šæ™ºèƒ½å·¥å…·åŒ…é€‰æ‹©
        toolkit_selection = await self.intelligent_toolkit_selection(analysis)
        
        # ç¬¬ä¸‰æ­¥ï¼šæ™ºèƒ½å·¥å…·ç­›é€‰
        tool_filtering = await self.intelligent_tool_filtering(
            user_query, toolkit_selection
        )
        
        return ToolDiscoveryResult(
            analysis=analysis,
            selected_toolkits=toolkit_selection.toolkits,
            recommended_tools=tool_filtering.tools,
            execution_plan=tool_filtering.execution_plan
        )
    
    async def analyze_query_intelligence(self, user_query: str) -> IntelligentAnalysisResult:
        """ç¬¬ä¸€æ­¥ï¼šæ™ºèƒ½æŸ¥è¯¢åˆ†æ"""
        prompt = f"""
        ä½œä¸ºæ™ºèƒ½å·¥å…·å‘ç°æœåŠ¡çš„åˆ†æå¼•æ“ï¼Œè¯·æ·±åº¦åˆ†æç”¨æˆ·æŸ¥è¯¢çš„æ ¸å¿ƒæ„å›¾å’ŒæŠ€æœ¯éœ€æ±‚ã€‚

        ç”¨æˆ·æŸ¥è¯¢: {user_query}

        è¯·ä»ä»¥ä¸‹ç»´åº¦è¿›è¡Œåˆ†æï¼š
        1. æ ¸å¿ƒæ„å›¾è¯†åˆ«ï¼šç”¨æˆ·æƒ³è¦å®Œæˆä»€ä¹ˆä¸»è¦ä»»åŠ¡ï¼Ÿ
        2. ä»»åŠ¡ç‰¹å¾åˆ†æï¼šæ•°æ®å¤„ç†/ç½‘é¡µäº¤äº’/ä»£ç æ‰§è¡Œ/æ–‡æ¡£åˆ†æç­‰
        3. å¤æ‚åº¦è¯„ä¼°ï¼šç®€å•/ä¸­ç­‰/å¤æ‚ï¼Œéœ€è¦å¤šå°‘ä¸ªæ­¥éª¤ï¼Ÿ
        4. è¾“å…¥è¾“å‡ºéœ€æ±‚ï¼šéœ€è¦ä»€ä¹ˆç±»å‹çš„è¾“å…¥ï¼ŒæœŸæœ›ä»€ä¹ˆå½¢å¼çš„è¾“å‡ºï¼Ÿ
        5. æŠ€æœ¯éœ€æ±‚è¯†åˆ«ï¼šæ˜¯å¦éœ€è¦ç‰¹å®šçš„æŠ€æœ¯èƒ½åŠ›ï¼Ÿ
        6. åœºæ™¯åˆ†ç±»ï¼šåŸºäºä»¥ä¸Šåˆ†æï¼Œè¿™å±äºä»€ä¹ˆç±»å‹çš„åº”ç”¨åœºæ™¯ï¼Ÿï¼ˆå¯ä»¥åˆ›æ–°æ€§åœ°å‘½åï¼‰

        è¯·æä¾›è¯¦ç»†çš„åˆ†æç»“æœå’Œæ¨ç†è¿‡ç¨‹ã€‚
        """
        
        response = await self.llm_client.analyze(prompt)
        return IntelligentAnalysisResult.from_llm_response(response)
```

### 3.3 MCPæ„å»ºå·¥å…· (MCPBuilderTool)

å°†MCPè‡ªåŠ¨æ„å»ºä½œä¸ºä¸€ä¸ªç‰¹æ®Šçš„ç³»ç»Ÿå·¥å…·ã€‚

```python
class MCPBuilderTool:
    """MCPè‡ªåŠ¨æ„å»ºå·¥å…· - å¤„ç†èƒ½åŠ›ç¼ºå£"""
    
    def __init__(self):
        self.name = "mcp_auto_builder"
        self.description = "å½“ç°æœ‰å·¥å…·æ— æ³•æ»¡è¶³ç”¨æˆ·éœ€æ±‚æ—¶ï¼Œè‡ªåŠ¨æ„å»ºæ–°çš„MCP Server"
        self.capability_type = "meta_tool"  # å…ƒå·¥å…·ç±»å‹
        self.builder_client = MCPBuilderClient()  # æ„å»ºç¯å¢ƒå®¢æˆ·ç«¯
    
    async def create_mcp_for_gap(self, gap: CapabilityGap) -> Optional[Tool]:
        """ä¸ºèƒ½åŠ›ç¼ºå£åˆ›å»ºMCP"""
        
        # 1. åˆ†æMCPéœ€æ±‚
        requirement = await self._analyze_mcp_requirement(gap)
        
        # 2. æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç±»ä¼¼MCP
        existing_mcp = await self._find_existing_solution(requirement)
        if existing_mcp:
            return await self._integrate_existing_mcp(existing_mcp)
        
        # 3. è°ƒç”¨ç‹¬ç«‹æ„å»ºç¯å¢ƒåˆ›å»ºæ–°MCP
        build_request = MCPBuildRequest(
            requirement=requirement,
            priority="high",
            context=gap.context
        )
        
        build_result = await self.builder_client.submit_build_request(build_request)
        
        if build_result.success:
            # 4. æ³¨å†Œæ–°MCPåˆ°å·¥å…·åº“
            new_tool = await self._register_new_mcp(build_result.mcp_asset)
            return new_tool
        
        return None
    
    async def _analyze_mcp_requirement(self, gap: CapabilityGap) -> MCPRequirement:
        """åˆ†æMCPæ„å»ºéœ€æ±‚"""
        prompt = f"""
        åŸºäºæ£€æµ‹åˆ°çš„èƒ½åŠ›ç¼ºå£ï¼Œåˆ†æéœ€è¦æ„å»ºçš„MCP Serverè¦æ±‚ï¼š

        ç¼ºå£æè¿°: {gap.description}
        æŠ€æœ¯éœ€æ±‚: {gap.technical_requirements}
        ä½¿ç”¨åœºæ™¯: {gap.context}

        è¯·åˆ†æï¼š
        1. MCP Serveråº”è¯¥æä¾›ä»€ä¹ˆæ ¸å¿ƒåŠŸèƒ½ï¼Ÿ
        2. éœ€è¦å“ªäº›å¤–éƒ¨ä¾èµ–å’Œåº“ï¼Ÿ
        3. é¢„æœŸçš„è¾“å…¥è¾“å‡ºæ ¼å¼æ˜¯ä»€ä¹ˆï¼Ÿ
        4. æœ‰å“ªäº›ç°æœ‰çš„å¼€æºé¡¹ç›®å¯ä»¥å‚è€ƒï¼Ÿ
        """
        
        response = await self.llm_client.analyze(prompt)
        return MCPRequirement.from_llm_response(response)
```

### 3.4 æ‰§è¡Œæ²™ç›’Agentå¢å¼º

åœ¨ç°æœ‰sandbox Agentä¸­é›†æˆæ™ºèƒ½å·¥å…·å‘ç°å’ŒMCPæ„å»ºèƒ½åŠ›ã€‚

```python
class EnhancedSandboxAgent:
    """å¢å¼ºçš„æ‰§è¡Œæ²™ç›’Agent - é›†æˆæ™ºèƒ½å·¥å…·å‘ç°"""
    
    def __init__(self):
        # === ç°æœ‰ç»„ä»¶ (ä¿æŒä¸å˜) ===
        self.scenario_identifier = ScenarioIdentifier()
        self.task_decomposer = TaskDecomposer()
        self.execution_coordinator = ExecutionCoordinator()
        
        # === æ–°å¢ï¼šæ™ºèƒ½å·¥å…·å‘ç° ===
        self.tool_library = UnifiedToolLibrary()
        
    async def execute_user_query(self, user_query: str) -> ExecutionResult:
        """æ‰§è¡Œç”¨æˆ·æŸ¥è¯¢ - é›†æˆæ™ºèƒ½å·¥å…·å‘ç°"""
        
        # 1. ä»»åŠ¡åˆ†è§£ (ç°æœ‰é€»è¾‘)
        tasks = await self.task_decomposer.decompose(user_query)
        
        # 2. æ™ºèƒ½å·¥å…·å‘ç° (æ–°å¢)
        discovery_result = await self.tool_library.discover_tools(user_query)
        
        # 3. èƒ½åŠ›ç¼ºå£æ£€æµ‹ (æ–°å¢)
        sufficient = await self._assess_tool_sufficiency(tasks, discovery_result.recommended_tools)
        
        if not sufficient:
            # æ£€æµ‹åˆ°èƒ½åŠ›ç¼ºå£ - è§¦å‘MCPæ„å»º
            gaps = await self._identify_capability_gaps(tasks, discovery_result.recommended_tools)
            
            for gap in gaps:
                new_tool = await self.tool_library.handle_capability_gap(gap)
                if new_tool:
                    discovery_result.recommended_tools.append(new_tool)
        
        # 4. æ‰§è¡Œä»»åŠ¡ (ç°æœ‰é€»è¾‘)
        return await self.execution_coordinator.execute(
            tasks=tasks,
            tools=discovery_result.recommended_tools,
            execution_plan=discovery_result.execution_plan
        )
```

---

## 4. æ•°æ®æ¨¡å‹è®¾è®¡

### 4.1 æ ¸å¿ƒæ•°æ®ç»“æ„

```python
@dataclass
class Tool:
    """å·¥å…·åŸºç¡€æ¨¡å‹"""
    id: str
    name: str
    description: str
    toolkit_id: str
    tool_type: ToolType  # FUNCTION_TOOL, MCP_SERVER
    parameters: Dict[str, Any]
    execution_endpoint: str
    effectiveness_score: float = 0.0
    usage_count: int = 0
    created_at: datetime
    
@dataclass
class Toolkit:
    """å·¥å…·åŒ…æ¨¡å‹"""
    id: str
    name: str
    description: str
    category: str
    tools: List[Tool]
    compatibility_score: float = 0.0
    
@dataclass
class CapabilityGap:
    """èƒ½åŠ›ç¼ºå£æ¨¡å‹"""
    description: str
    technical_requirements: List[str]
    priority: str  # high, medium, low
    context: str
    search_keywords: List[str]
    
@dataclass
class MCPBuildRequest:
    """MCPæ„å»ºè¯·æ±‚"""
    requirement: MCPRequirement
    priority: str
    context: str
    timeout: int = 600  # 10åˆ†é’Ÿ
```

### 4.2 æ™ºèƒ½å‘ç°ç»“æœæ¨¡å‹

```python
@dataclass
class IntelligentAnalysisResult:
    """æ™ºèƒ½æŸ¥è¯¢åˆ†æç»“æœ"""
    core_intent: str
    task_characteristics: List[str]
    complexity_level: str
    input_output_requirements: Dict[str, str]
    technical_needs: List[str]
    scenario_classification: str
    confidence_score: float
    reasoning: str

@dataclass
class ToolkitSelectionResult:
    """å·¥å…·åŒ…é€‰æ‹©ç»“æœ"""
    toolkits: List[Toolkit]
    selection_reasoning: str
    combination_strategy: str
    alternatives: List[Toolkit]

@dataclass
class ToolFilteringResult:
    """å·¥å…·ç­›é€‰ç»“æœ"""
    tools: List[Tool]
    execution_plan: ExecutionPlan
    reasoning: str
    backup_options: List[Tool]
```

---

## 5. MCPæ„å»ºå·¥å…·é›†æˆ

### 5.1 MCPæ„å»ºä½œä¸ºç‰¹æ®Šå·¥å…·

MCPè‡ªåŠ¨æ„å»ºè¢«è®¾è®¡ä¸ºä¸€ä¸ªç‰¹æ®Šçš„"å…ƒå·¥å…·"ï¼Œå½“ç°æœ‰å·¥å…·åº“æ— æ³•æ»¡è¶³ç”¨æˆ·éœ€æ±‚æ—¶è‡ªåŠ¨æ¿€æ´»ï¼š

```python
class MCPBuilderTool:
    """MCPæ„å»ºå·¥å…· - å…ƒå·¥å…·ç±»å‹"""
    
    @property
    def tool_info(self) -> Dict[str, Any]:
        return {
            "name": "mcp_auto_builder",
            "type": "meta_tool",
            "description": "å½“æ£€æµ‹åˆ°èƒ½åŠ›ç¼ºå£æ—¶ï¼Œè‡ªåŠ¨æ„å»ºæ–°çš„MCP Serveræ¥å¡«è¡¥åŠŸèƒ½ç©ºç™½",
            "activation_condition": "existing_tools_insufficient",
            "capabilities": [
                "éœ€æ±‚åˆ†æ", "ä»£ç ç”Ÿæˆ", "ç¯å¢ƒæ„å»º", "åŠŸèƒ½éªŒè¯", "å·¥å…·æ³¨å†Œ"
            ]
        }
    
    async def is_activation_needed(self, tasks: List[Task], available_tools: List[Tool]) -> bool:
        """åˆ¤æ–­æ˜¯å¦éœ€è¦æ¿€æ´»MCPæ„å»º"""
        coverage = await self._calculate_task_coverage(tasks, available_tools)
        return coverage < 0.8  # è¦†ç›–ç‡ä½äº80%æ—¶æ¿€æ´»
```

### 5.2 ä¸æ„å»ºç¯å¢ƒçš„äº¤äº’

MCPæ„å»ºå·¥å…·é€šè¿‡æ ‡å‡†APIä¸ç‹¬ç«‹çš„MCPæ„å»ºç¯å¢ƒäº¤äº’ï¼š

```python
class MCPBuilderClient:
    """MCPæ„å»ºç¯å¢ƒå®¢æˆ·ç«¯"""
    
    def __init__(self, builder_service_url: str):
        self.service_url = builder_service_url
        self.http_client = httpx.AsyncClient()
    
    async def submit_build_request(self, request: MCPBuildRequest) -> MCPBuildResponse:
        """æäº¤MCPæ„å»ºè¯·æ±‚åˆ°ç‹¬ç«‹æ„å»ºç¯å¢ƒ"""
        
        response = await self.http_client.post(
            f"{self.service_url}/api/v1/build",
            json=request.to_dict(),
            timeout=30
        )
        
        return MCPBuildResponse.from_json(response.json())
    
    async def get_build_status(self, build_id: str) -> MCPBuildStatus:
        """è·å–æ„å»ºçŠ¶æ€"""
        
        response = await self.http_client.get(
            f"{self.service_url}/api/v1/build/{build_id}/status"
        )
        
        return MCPBuildStatus.from_json(response.json())
```

**æ³¨æ„**: MCPæ„å»ºç¯å¢ƒçš„å…·ä½“æŠ€æœ¯å®ç°ï¼ˆä»£ç ç”Ÿæˆã€ç¯å¢ƒç®¡ç†ã€æµ‹è¯•éªŒè¯ç­‰ï¼‰å°†åœ¨å•ç‹¬çš„ `MCPè‡ªåŠ¨æ„å»ºç¯å¢ƒå¼€å‘æ–‡æ¡£` ä¸­è¯¦ç»†è¯´æ˜ã€‚

---

## 6. å…¼å®¹æ€§ä¸è¿ç§»

### 6.1 æ¸è¿›å¼è¿ç§»ç­–ç•¥

1. **Phase 1**: éƒ¨ç½²ç»Ÿä¸€å·¥å…·åº“ï¼Œç°æœ‰è¿è¡Œæ—¶é€šè¿‡é€‚é…å™¨è®¿é—®
2. **Phase 2**: å‡çº§æ‰§è¡Œæ²™ç›’Agentï¼Œé›†æˆæ™ºèƒ½å‘ç°æœåŠ¡
3. **Phase 3**: éƒ¨ç½²MCPæ„å»ºç¯å¢ƒï¼Œå¯ç”¨è‡ªåŠ¨å·¥å…·åˆ›å»º
4. **Phase 4**: å®Œå…¨åˆ‡æ¢åˆ°æ–°æ¶æ„ï¼Œç§»é™¤æ—§ä»£ç 

### 6.2 APIå…¼å®¹æ€§ä¿è¯

```python
class CompatibilityAdapter:
    """å…¼å®¹æ€§é€‚é…å™¨ - ä¿è¯ç°æœ‰APIæ­£å¸¸å·¥ä½œ"""
    
    async def get_capabilities(self, runtime_type: str) -> List[str]:
        """é€‚é…ç°æœ‰çš„capabilitiesæ¥å£"""
        
        # è½¬æ¢ä¸ºæ–°çš„å·¥å…·å‘ç°è°ƒç”¨
        toolkits = await self.tool_library.get_toolkits_by_category(runtime_type)
        
        # è¿”å›å…¼å®¹æ ¼å¼
        return [tool.name for toolkit in toolkits for tool in toolkit.tools]
    
    async def execute_tool(self, tool_name: str, action: str, params: Dict) -> Dict:
        """é€‚é…ç°æœ‰çš„å·¥å…·æ‰§è¡Œæ¥å£"""
        
        # é€šè¿‡æ–°çš„ç»Ÿä¸€è°ƒåº¦å™¨æ‰§è¡Œ
        tool = await self.tool_library.find_tool(tool_name)
        return await self.tool_library.unified_dispatcher.execute(tool, action, params)
```

---

## 7. ç›‘æ§ä¸ä¼˜åŒ–

### 7.1 å…³é”®æŒ‡æ ‡

- **å·¥å…·å‘ç°æ•ˆç‡**: æ™ºèƒ½å‘ç°æœåŠ¡å“åº”æ—¶é—´ < 500ms
- **å·¥å…·é€‰æ‹©å‡†ç¡®ç‡**: Agenté€‰æ‹©æ­£ç¡®å·¥å…·çš„æ¯”ä¾‹ > 90%
- **MCPæ„å»ºæˆåŠŸç‡**: è‡ªåŠ¨MCPåˆ›å»ºæˆåŠŸç‡ > 80%
- **ç³»ç»Ÿå¯ç”¨æ€§**: å·¥å…·åº“æœåŠ¡å¯ç”¨æ€§ > 99.9%

### 7.2 æŒç»­ä¼˜åŒ–æœºåˆ¶

```python
class ToolUsageOptimizer:
    """å·¥å…·ä½¿ç”¨ä¼˜åŒ–å™¨"""
    
    async def optimize_based_on_trajectory(self, trajectory: ExecutionTrajectory):
        """åŸºäºæ‰§è¡Œè½¨è¿¹ä¼˜åŒ–å·¥å…·æ¨è"""
        
        # åˆ†æå·¥å…·ä½¿ç”¨æ•ˆæœ
        effectiveness = await self._analyze_tool_effectiveness(trajectory)
        
        # æ›´æ–°å·¥å…·è¯„åˆ†
        await self._update_tool_scores(effectiveness)
        
        # ä¼˜åŒ–å·¥å…·æè¿°
        await self._optimize_tool_descriptions(trajectory)
        
        # è°ƒæ•´å·¥å…·åˆ†ç±»
        await self._refine_toolkit_categorization(trajectory)
```

---

## 8. éƒ¨ç½²ä¸è¿ç»´

### 8.1 æœåŠ¡éƒ¨ç½²æ¶æ„

```yaml
# docker-compose.yml æ‰©å±•
services:
  # ç°æœ‰æœåŠ¡...
  
  unified-tool-library:
    build: ./tool-library
    environment:
      - REDIS_URL=redis://redis:6379
      - POSTGRES_URL=postgresql://user:pass@postgres:5432/tooldb
    depends_on:
      - redis
      - postgres
    
  mcp-builder-service:
    build: ./mcp-builder-env
    environment:
      - DOCKER_HOST=unix:///var/run/docker.sock
      - BUILD_TIMEOUT=600
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    privileged: true
```

### 8.2 ç›‘æ§é…ç½®

```python
# ç›‘æ§æŒ‡æ ‡é…ç½®
METRICS_CONFIG = {
    "tool_discovery_latency": {
        "type": "histogram",
        "buckets": [0.1, 0.5, 1.0, 2.0, 5.0]
    },
    "mcp_build_success_rate": {
        "type": "gauge",
        "alert_threshold": 0.8
    },
    "tool_effectiveness_score": {
        "type": "histogram",
        "buckets": [0.1, 0.3, 0.5, 0.7, 0.9, 1.0]
    }
}
```

---

## 9. é£é™©è¯„ä¼°ä¸ç¼“è§£

### 9.1 ä¸»è¦é£é™©

1. **MCPæ„å»ºå¤±è´¥**: è‡ªåŠ¨æ„å»ºçš„MCPå¯èƒ½å­˜åœ¨åŠŸèƒ½ç¼ºé™·
   - **ç¼“è§£**: å¤šå±‚æµ‹è¯•éªŒè¯ï¼Œå¤±è´¥æ—¶å›é€€åˆ°ç°æœ‰å·¥å…·
   
2. **æ€§èƒ½å½±å“**: æ™ºèƒ½å‘ç°å¯èƒ½å¢åŠ å“åº”å»¶è¿Ÿ
   - **ç¼“è§£**: å¹¶è¡Œå¤„ç†ï¼Œç¼“å­˜æœºåˆ¶ï¼Œè¶…æ—¶ä¿æŠ¤

3. **å…¼å®¹æ€§é—®é¢˜**: æ–°æ—§ç³»ç»Ÿåˆ‡æ¢è¿‡ç¨‹ä¸­çš„å…¼å®¹æ€§é£é™©
   - **ç¼“è§£**: æ¸è¿›å¼è¿ç§»ï¼Œå®Œæ•´çš„å›æ»šæœºåˆ¶

### 9.2 ç›‘æ§å‘Šè­¦

```python
ALERT_RULES = {
    "tool_discovery_timeout": {
        "condition": "tool_discovery_latency > 5s",
        "action": "fallback_to_static_tools"
    },
    "mcp_build_failure_rate": {
        "condition": "mcp_build_success_rate < 0.8",
        "action": "disable_auto_mcp_building"
    }
}
```

---

## 10. æˆåŠŸåº¦é‡æŒ‡æ ‡

### 10.1 æŠ€æœ¯æŒ‡æ ‡

- **å¼€å‘æ•ˆç‡**: æ–°å¢å·¥å…·å¼€å‘æ—¶é—´å‡å°‘ 80%
- **ç³»ç»Ÿç¨³å®šæ€§**: å·¥å…·ç›¸å…³bugå‡å°‘ 90%
- **å“åº”æ€§èƒ½**: å·¥å…·å‘ç°å’Œæ‰§è¡Œå»¶è¿Ÿ < 500ms
- **è¦†ç›–ç‡**: è‡ªåŠ¨åŒ–æµ‹è¯•è¦†ç›–ç‡ > 95%

### 10.2 ä¸šåŠ¡æŒ‡æ ‡

- **ç”¨æˆ·æ»¡æ„åº¦**: å·¥å…·ä½¿ç”¨ä½“éªŒè¯„åˆ† > 4.5/5
- **ä»»åŠ¡æˆåŠŸç‡**: Agentä»»åŠ¡å®Œæˆç‡æå‡ 15%
- **åˆ›æ–°èƒ½åŠ›**: ç³»ç»Ÿè‡ªä¸»åˆ›å»ºçš„æœ‰æ•ˆå·¥å…·æ•°é‡ > 50/æœˆ

---

## æ€»ç»“

æ–°ä¸€ä»£å·¥å…·æ³¨å†Œä¸è°ƒç”¨ç³»ç»Ÿé€šè¿‡å¼•å…¥æ™ºèƒ½å‘ç°æœåŠ¡å’Œè‡ªåŠ¨MCPæ„å»ºèƒ½åŠ›ï¼Œå®ç°äº†ä»"ç¡¬ç¼–ç å·¥å…·ç®¡ç†"åˆ°"æ™ºèƒ½å·¥å…·ç”Ÿæ€"çš„æ ¹æœ¬æ€§è½¬å˜ã€‚ç³»ç»Ÿä¸ä»…è§£å†³äº†ç°æœ‰çš„æ‰©å±•æ€§å’Œç»´æŠ¤æ€§é—®é¢˜ï¼Œæ›´å¼€å¯äº†Agentè‡ªä¸»åˆ›é€ å·¥å…·çš„æ–°æ—¶ä»£ã€‚

**æ ¸å¿ƒåˆ›æ–°ç‚¹**:
1. **å®Œå…¨å»é™¤é¢„å®šä¹‰è§„åˆ™**: åŸºäºAgentè‡ªä¸»æ¨ç†çš„å·¥å…·å‘ç°
2. **ä¸‰å±‚é€’è¿›æ¨ç†**: æŸ¥è¯¢åˆ†æ â†’ å·¥å…·åŒ…é€‰æ‹© â†’ å·¥å…·ç­›é€‰  
3. **åŠ¨æ€å·¥å…·åˆ›å»º**: è‡ªåŠ¨MCPæ„å»ºå¡«è¡¥èƒ½åŠ›ç¼ºå£
4. **æ¸è¿›å¼å‡çº§**: ä¿è¯å…¼å®¹æ€§çš„å¹³æ»‘è¿ç§»è·¯å¾„

**æŠ€æœ¯ä»·å€¼**:
- å¼€å‘æ•ˆç‡æå‡80%ï¼Œç»´æŠ¤æˆæœ¬é™ä½90%
- ç³»ç»Ÿå…·å¤‡çœŸæ­£çš„è‡ªä¸»è¿›åŒ–èƒ½åŠ›
- ä¸ºæœªæ¥çš„AI Agentç”Ÿæ€å¥ å®šåšå®åŸºç¡€

### 8.5.6 åŸºäºAlitaèŒƒå¼çš„MCPæ„é€ æ¨¡å—è¯¦ç»†è®¾è®¡

**æ ¸å¿ƒè®¾è®¡åŸåˆ™ï¼šæœ€å°é¢„å®šä¹‰ + æœ€å¤§è‡ªè¿›åŒ–**

åŸºäºæ™®æ—æ–¯é¡¿å¤§å­¦Alitaè®ºæ–‡çš„çªç ´æ€§ç†å¿µï¼Œæˆ‘ä»¬çš„MCPè‡ªåŠ¨æ„å»ºæ¨¡å—å®Œå…¨é‡‡ç”¨**"Simplicity is the ultimate sophistication"**çš„æç®€ä¸»ä¹‰è®¾è®¡å“²å­¦ã€‚

#### Alitaæ ¸å¿ƒæ€æƒ³åœ¨MCPæ„é€ ä¸­çš„åº”ç”¨

**1. æç®€é¢„å®šä¹‰æ¶æ„**

```python
class MinimalMCPBuilder:
    """åŸºäºAlitaç†å¿µçš„æç®€MCPæ„å»ºå™¨"""
    
    def __init__(self):
        # åªæœ‰ä¸¤ä¸ªæ ¸å¿ƒç»„ä»¶ - å®Œå…¨éµå¾ªAlitaèŒƒå¼
        self.manager_agent = MCPManagerAgent()  # ä¸­å¤®åè°ƒå™¨
        self.web_agent = WebSearchAgent()       # ç½‘ç»œèµ„æºæœç´¢
        
        # æ²¡æœ‰ä»»ä½•é¢„å®šä¹‰çš„å·¥å…·åº“æˆ–å·¥ä½œæµ
        # æ‰€æœ‰èƒ½åŠ›éƒ½é€šè¿‡è‡ªä¸»è¿›åŒ–è·å¾—
        self.mcp_storage = {}  # åŠ¨æ€æ„å»ºçš„MCPå­˜å‚¨
        
    async def analyze_capability_gap(self, user_query: str, existing_tools: List[Tool]) -> MCPRequirement:
        """Alitaå¼èƒ½åŠ›ç¼ºå£åˆ†æ - MCP Brainstormingæ¨¡å—"""
        
        capability_analysis_prompt = f"""
        ä½ æ˜¯ä¸€ä¸ªæ™ºèƒ½çš„MCPéœ€æ±‚åˆ†æAgentã€‚åˆ†æç”¨æˆ·æŸ¥è¯¢å¹¶è¯„ä¼°ç°æœ‰å·¥å…·çš„èƒ½åŠ›ç¼ºå£ã€‚

        ç”¨æˆ·æŸ¥è¯¢: {user_query}
        ç°æœ‰å·¥å…·: {[tool.description for tool in existing_tools]}

        è¯·æŒ‰ç…§ä»¥ä¸‹ç»“æ„è¿›è¡Œåˆ†æ:

        1. **ä»»åŠ¡æœ¬è´¨ç†è§£**:
           - è¯†åˆ«ä»»åŠ¡çš„æ ¸å¿ƒéœ€æ±‚
           - åˆ†æä»»åŠ¡å¤æ‚åº¦å’ŒæŠ€æœ¯è¦æ±‚
           - è¯„ä¼°è¾“å…¥è¾“å‡ºç±»å‹

        2. **èƒ½åŠ›ç¼ºå£è¯†åˆ«**:
           - ç°æœ‰å·¥å…·è¦†ç›–äº†å“ªäº›èƒ½åŠ›ï¼Ÿ
           - è¿˜ç¼ºå°‘å“ªäº›å…³é”®èƒ½åŠ›ï¼Ÿ
           - ç¼ºå£çš„ä¸¥é‡ç¨‹åº¦å’Œä¼˜å…ˆçº§ï¼Ÿ

        3. **MCPæ„å»ºå»ºè®®**:
           - éœ€è¦æ„å»ºä»€ä¹ˆç±»å‹çš„MCPï¼Ÿ
           - MCPåº”è¯¥å…·å¤‡å“ªäº›å…·ä½“åŠŸèƒ½ï¼Ÿ
           - é¢„æœŸçš„æŠ€æœ¯å®ç°è·¯å¾„ï¼Ÿ

        4. **æˆåŠŸæ ‡å‡†å®šä¹‰**:
           - å¦‚ä½•éªŒè¯MCPçš„åŠŸèƒ½æ­£ç¡®æ€§ï¼Ÿ
           - æ€§èƒ½å’Œè´¨é‡çš„æœŸæœ›æŒ‡æ ‡ï¼Ÿ
        """
        
        response = await self.manager_agent.analyze(capability_analysis_prompt)
        return MCPRequirement.from_analysis(response)

    async def autonomous_mcp_creation(self, requirement: MCPRequirement) -> MCPAsset:
        """Alitaå¼è‡ªä¸»MCPåˆ›å»ºæµç¨‹"""
        
        # ç¬¬ä¸€æ­¥ï¼šç½‘ç»œæ™ºèƒ½ä½“æœç´¢ç›¸å…³èµ„æº
        search_results = await self.web_agent.search_open_source_resources(
            query=requirement.technical_keywords,
            domains=["github.com", "stackoverflow.com", "pypi.org"],
            max_results=10
        )
        
        # ç¬¬äºŒæ­¥ï¼šç®¡ç†æ™ºèƒ½ä½“åˆæˆMCPè„šæœ¬
        mcp_script = await self.manager_agent.synthesize_mcp_script(
            requirement=requirement,
            external_resources=search_results,
            reference_implementations=self._get_similar_mcps(requirement)
        )
        
        # ç¬¬ä¸‰æ­¥ï¼šåœ¨éš”ç¦»ç¯å¢ƒä¸­éªŒè¯MCP
        validation_result = await self._validate_mcp_in_isolation(mcp_script)
        
        if validation_result.success:
            # æ³¨å†Œä¸ºå¯å¤ç”¨çš„MCPèµ„äº§
            mcp_asset = MCPAsset(
                id=generate_mcp_id(),
                script=mcp_script,
                requirement=requirement,
                validation_result=validation_result,
                creation_timestamp=datetime.now(),
                usage_count=0,
                effectiveness_score=1.0  # åˆå§‹åˆ†æ•°
            )
            
            # å­˜å‚¨åˆ°MCPä»“åº“
            self.mcp_storage[mcp_asset.id] = mcp_asset
            return mcp_asset
        else:
            # å¤±è´¥åˆ™è¿›å…¥è‡ªæ„ˆæµç¨‹
            return await self._self_healing_reconstruction(requirement, validation_result.error_details)
```

**2. ä¸‰æ­¥CodeReActè‡ªè¿›åŒ–å¾ªç¯**

```python
class AlitaStyleCodeReActLoop:
    """åŸºäºAlitaçš„CodeReActè‡ªè¿›åŒ–å¾ªç¯"""
    
    async def execute_creation_cycle(self, mcp_requirement: MCPRequirement) -> MCPAsset:
        """æ‰§è¡Œå®Œæ•´çš„MCPåˆ›å»ºå¾ªç¯"""
        
        max_iterations = 3
        for iteration in range(max_iterations):
            
            # === é˜¶æ®µ1ï¼šCode (ä»£ç ç”Ÿæˆ) ===
            code_generation_result = await self._generate_mcp_code(
                requirement=mcp_requirement,
                previous_attempts=iteration > 0,
                error_feedback=getattr(self, 'last_error', None)
            )
            
            # === é˜¶æ®µ2ï¼šReAct (æ¨ç†ä¸è¡ŒåŠ¨) ===
            reasoning_result = await self._reasoning_and_action(
                generated_code=code_generation_result.code,
                requirement=mcp_requirement,
                context=code_generation_result.generation_context
            )
            
            # === é˜¶æ®µ3ï¼šAction (æ‰§è¡Œä¸éªŒè¯) ===
            execution_result = await self._execute_and_validate(
                code=reasoning_result.refined_code,
                test_cases=reasoning_result.generated_tests,
                environment=reasoning_result.environment_setup
            )
            
            if execution_result.success:
                # æˆåŠŸ - æ³¨å†ŒMCPå¹¶è·³å‡ºå¾ªç¯
                return await self._register_successful_mcp(
                    code=execution_result.validated_code,
                    metadata=execution_result.metadata,
                    requirement=mcp_requirement
                )
            else:
                # å¤±è´¥ - è®°å½•é”™è¯¯ï¼Œå‡†å¤‡ä¸‹ä¸€æ¬¡è¿­ä»£
                self.last_error = execution_result.error_details
                await self._learn_from_failure(execution_result.error_details)
        
        # è¾¾åˆ°æœ€å¤§è¿­ä»£æ¬¡æ•°ä»å¤±è´¥ - é™çº§å¤„ç†
        return await self._fallback_strategy(mcp_requirement)

    async def _generate_mcp_code(self, requirement: MCPRequirement, 
                                previous_attempts: bool, error_feedback: Optional[str]) -> CodeGenerationResult:
        """Alitaå¼ä»£ç ç”Ÿæˆ"""
        
        generation_prompt = f"""
        ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„MCPä»£ç ç”Ÿæˆå™¨ï¼ŒåŸºäºå¼€æºèµ„æºå’Œæœ€ä½³å®è·µè‡ªä¸»åˆ›å»ºMCP Serverã€‚

        ä»»åŠ¡éœ€æ±‚: {requirement.description}
        æŠ€æœ¯è¦æ±‚: {requirement.technical_specs}
        å¤–éƒ¨èµ„æº: {requirement.external_resources}

        {f"ä¸Šæ¬¡å°è¯•å¤±è´¥ï¼Œé”™è¯¯ä¿¡æ¯: {error_feedback}" if previous_attempts else ""}

        è¯·ç”Ÿæˆä¸€ä¸ªå®Œæ•´çš„MCP Serverå®ç°ï¼ŒåŒ…æ‹¬:

        1. **å®Œæ•´çš„Python MCP Serverä»£ç **
        2. **ç¯å¢ƒä¾èµ–æ¸…å•** (requirements.txt)
        3. **å¯åŠ¨é…ç½®è„šæœ¬** (setup.sh)
        4. **æµ‹è¯•éªŒè¯ä»£ç ** (test_mcp.py)
        5. **ä½¿ç”¨è¯´æ˜æ–‡æ¡£** (README.md)

        éµå¾ªMCPåè®®æ ‡å‡†ï¼Œç¡®ä¿:
        - æ­£ç¡®çš„æœåŠ¡å™¨åˆå§‹åŒ–
        - æ ‡å‡†çš„å·¥å…·æ³¨å†Œæ ¼å¼
        - é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•
        - èµ„æºæ¸…ç†å’Œä¼˜é›…é€€å‡º

        ä»£ç è¦æ±‚:
        - é«˜è´¨é‡ã€å¯ç»´æŠ¤
        - å……åˆ†çš„é”™è¯¯å¤„ç†
        - è¯¦ç»†çš„æ³¨é‡Šè¯´æ˜
        - éµå¾ªPythonæœ€ä½³å®è·µ
        """
        
        response = await self.llm_client.generate(generation_prompt)
        
        return CodeGenerationResult(
            code=response.extracted_code,
            dependencies=response.dependencies,
            setup_commands=response.setup_commands,
            tests=response.test_code,
            documentation=response.documentation,
            generation_context=response.reasoning
        )
```

**3. æ™ºèƒ½MCPä»“åº“ - çŸ¥è¯†ç§¯ç´¯ä¸å¤ç”¨**

```python
class IntelligentMCPRepository:
    """åŸºäºAlitaç†å¿µçš„æ™ºèƒ½MCPä»“åº“ - å®ç°é›†ä½“æ™ºèƒ½"""
    
    def __init__(self):
        self.mcp_embeddings = {}  # MCPåŠŸèƒ½åµŒå…¥å‘é‡
        self.usage_analytics = {}  # ä½¿ç”¨åˆ†ææ•°æ®
        self.success_patterns = {}  # æˆåŠŸæ¨¡å¼å­¦ä¹ 
        
    async def find_similar_mcps(self, requirement: MCPRequirement) -> List[MCPAsset]:
        """æ™ºèƒ½ç›¸ä¼¼MCPå‘ç° - æ”¯æŒçŸ¥è¯†å¤ç”¨"""
        
        requirement_embedding = await self.embedding_service.encode(
            f"{requirement.description} {requirement.technical_specs}"
        )
        
        similarities = []
        for mcp_id, mcp_asset in self.mcp_storage.items():
            mcp_embedding = self.mcp_embeddings[mcp_id]
            similarity = cosine_similarity(requirement_embedding, mcp_embedding)
            
            if similarity > 0.7:  # é«˜ç›¸ä¼¼åº¦é˜ˆå€¼
                similarities.append((similarity, mcp_asset))
        
        # æŒ‰ç›¸ä¼¼åº¦æ’åºï¼Œè¿”å›æœ€ç›¸å…³çš„MCP
        similarities.sort(key=lambda x: x[0], reverse=True)
        return [asset for _, asset in similarities[:5]]

    async def adaptive_mcp_optimization(self, mcp_id: str, usage_feedback: MCPUsageFeedback) -> None:
        """åŸºäºä½¿ç”¨åé¦ˆçš„è‡ªé€‚åº”MCPä¼˜åŒ–"""
        
        if mcp_id not in self.mcp_storage:
            return
        
        mcp_asset = self.mcp_storage[mcp_id]
        
        # æ›´æ–°æ•ˆæœè¯„åˆ†
        mcp_asset.effectiveness_score = self._calculate_effectiveness(
            current_score=mcp_asset.effectiveness_score,
            new_feedback=usage_feedback
        )
        
        # å­¦ä¹ æˆåŠŸæ¨¡å¼
        if usage_feedback.success_rate > 0.8:
            await self._extract_success_patterns(mcp_asset, usage_feedback)
        
        # è¯†åˆ«æ”¹è¿›æœºä¼š
        if usage_feedback.success_rate < 0.6:
            improvement_suggestions = await self._analyze_failure_patterns(
                mcp_asset, usage_feedback
            )
            await self._queue_mcp_improvement(mcp_id, improvement_suggestions)

    async def cross_agent_knowledge_transfer(self, target_agent_id: str, 
                                           capability_requirements: List[str]) -> List[MCPAsset]:
        """è·¨AgentçŸ¥è¯†è½¬ç§» - Alitaçš„é›†ä½“æ™ºèƒ½ç‰¹æ€§"""
        
        relevant_mcps = []
        
        for requirement in capability_requirements:
            # åŸºäºèƒ½åŠ›éœ€æ±‚åŒ¹é…MCP
            matching_mcps = await self.semantic_search(
                query=requirement,
                filters={'effectiveness_score__gte': 0.7, 'usage_count__gte': 5}
            )
            
            for mcp in matching_mcps:
                # è¯„ä¼°MCPå¯¹ç›®æ ‡Agentçš„é€‚ç”¨æ€§
                adaptability_score = await self._assess_mcp_adaptability(
                    mcp, target_agent_id
                )
                
                if adaptability_score > 0.8:
                    # å…‹éš†å¹¶å®šåˆ¶MCP
                    customized_mcp = await self._customize_mcp_for_agent(
                        mcp, target_agent_id
                    )
                    relevant_mcps.append(customized_mcp)
        
        return relevant_mcps
```

**4. æ•…éšœè‡ªæ„ˆæœºåˆ¶ - ä»é”™è¯¯ä¸­å­¦ä¹ **

```python
class AlitaSelfHealingMechanism:
    """åŸºäºAlitaçš„è‡ªæ„ˆæœºåˆ¶ - æœ€å¤§è‡ªè¿›åŒ–çš„ä½“ç°"""
    
    async def intelligent_failure_recovery(self, 
                                         failure_context: MCPCreationFailure) -> MCPAsset:
        """æ™ºèƒ½å¤±è´¥æ¢å¤ç­–ç•¥"""
        
        # åˆ†æå¤±è´¥åŸå› 
        failure_analysis = await self._analyze_failure_root_cause(failure_context)
        
        recovery_strategies = [
            self._dependency_resolution_strategy,
            self._alternative_implementation_strategy,
            self._simplified_functionality_strategy,
            self._external_service_integration_strategy
        ]
        
        for strategy in recovery_strategies:
            try:
                recovery_result = await strategy(failure_context, failure_analysis)
                if recovery_result.success:
                    # è®°å½•æˆåŠŸçš„æ¢å¤æ¨¡å¼
                    await self._record_successful_recovery_pattern(
                        failure_type=failure_analysis.failure_type,
                        recovery_strategy=strategy.__name__,
                        success_context=recovery_result.context
                    )
                    return recovery_result.mcp_asset
            except Exception as e:
                # è®°å½•å¤±è´¥çš„æ¢å¤å°è¯•
                await self._record_failed_recovery_attempt(strategy.__name__, str(e))
                continue
        
        # æ‰€æœ‰ç­–ç•¥éƒ½å¤±è´¥ - è§¦å‘äººå·¥ä»‹å…¥è¯·æ±‚
        await self._request_human_intervention(failure_context)
        raise MCPCreationException("All recovery strategies failed")

    async def _dependency_resolution_strategy(self, 
                                            failure_context: MCPCreationFailure,
                                            failure_analysis: FailureAnalysis) -> RecoveryResult:
        """ä¾èµ–è§£ææ¢å¤ç­–ç•¥"""
        
        if failure_analysis.failure_type != FailureType.DEPENDENCY_ERROR:
            raise StrategyNotApplicableException()
        
        # æ™ºèƒ½ä¾èµ–ç‰ˆæœ¬è°ƒæ•´
        dependency_suggestions = await self.dependency_resolver.suggest_compatible_versions(
            failed_dependencies=failure_analysis.problematic_dependencies,
            python_version=failure_context.target_environment.python_version,
            os_type=failure_context.target_environment.os_type
        )
        
        # é‡æ–°ç”Ÿæˆå…·æœ‰å…¼å®¹ä¾èµ–çš„MCP
        updated_mcp = await self.code_generator.regenerate_with_dependencies(
            original_code=failure_context.mcp_code,
            new_dependencies=dependency_suggestions
        )
        
        # åœ¨éš”ç¦»ç¯å¢ƒä¸­æµ‹è¯•
        validation_result = await self.environment_manager.validate_mcp(updated_mcp)
        
        if validation_result.success:
            return RecoveryResult(
                success=True,
                mcp_asset=updated_mcp,
                context={'strategy': 'dependency_resolution', 'changes': dependency_suggestions}
            )
        else:
            raise RecoveryFailedException("Dependency resolution failed")
```

**5. ä¸ç°æœ‰ç³»ç»Ÿçš„æ— ç¼é›†æˆ**

```python
class AlitaMCPIntegration:
    """Alitaå¼MCPæ„å»ºæ¨¡å—ä¸å·¥å…·åº“çš„é›†æˆ"""
    
    def __init__(self, tool_registry: ToolRegistry):
        self.tool_registry = tool_registry
        self.alita_builder = MinimalMCPBuilder()
        
    async def handle_capability_gap(self, 
                                   user_query: str, 
                                   discovery_result: ToolFilteringResult) -> IntegrationResult:
        """å¤„ç†æ™ºèƒ½å‘ç°æœåŠ¡æ£€æµ‹åˆ°çš„èƒ½åŠ›ç¼ºå£"""
        
        if discovery_result.selected_tools:
            # ç°æœ‰å·¥å…·è¶³å¤Ÿï¼Œæ— éœ€æ„å»ºMCP
            return IntegrationResult(
                action=IntegrationAction.USE_EXISTING_TOOLS,
                tools=discovery_result.selected_tools
            )
        
        # èƒ½åŠ›ç¼ºå£ - è§¦å‘Alitaå¼MCPæ„å»º
        mcp_requirement = await self.alita_builder.analyze_capability_gap(
            user_query=user_query,
            existing_tools=discovery_result.available_tools
        )
        
        # æ£€æŸ¥æ˜¯å¦å¯ä»¥å¤ç”¨ç°æœ‰MCP
        similar_mcps = await self.alita_builder.mcp_repository.find_similar_mcps(
            mcp_requirement
        )
        
        if similar_mcps:
            # å¤ç”¨ç°æœ‰MCP
            best_match = similar_mcps[0]
            await self.tool_registry.register_mcp_server(best_match)
            
            return IntegrationResult(
                action=IntegrationAction.REUSE_EXISTING_MCP,
                mcp_asset=best_match
            )
        
        # åˆ›å»ºæ–°MCP
        try:
            new_mcp = await self.alita_builder.autonomous_mcp_creation(mcp_requirement)
            
            # è‡ªåŠ¨æ³¨å†Œåˆ°å·¥å…·åº“
            registration_result = await self.tool_registry.register_mcp_server(new_mcp)
            
            # è§¦å‘é‡æ–°å‘ç°
            if registration_result.success:
                return IntegrationResult(
                    action=IntegrationAction.CREATED_NEW_MCP,
                    mcp_asset=new_mcp,
                    retry_discovery=True
                )
                
        except MCPCreationException as e:
            # åˆ›å»ºå¤±è´¥ - è®°å½•å¹¶è¿”å›é”™è¯¯
            await self._log_creation_failure(user_query, mcp_requirement, str(e))
            
            return IntegrationResult(
                action=IntegrationAction.CREATION_FAILED,
                error_message=f"MCPåˆ›å»ºå¤±è´¥: {str(e)}",
                fallback_suggestion="è¯·å°è¯•è°ƒæ•´æŸ¥è¯¢æˆ–æ‰‹åŠ¨æä¾›ç›¸å…³å·¥å…·"
            )
```

#### æ ¸å¿ƒä¼˜åŠ¿å¯¹æ¯”

| ç»´åº¦ | ä¼ ç»Ÿé¢„å®šä¹‰æ–¹æ¡ˆ | Alitaå¼MCPæ„å»º |
|------|---------------|----------------|
| **è®¾è®¡å¤æ‚åº¦** | é«˜åº¦å¤æ‚ï¼Œä¾èµ–å¤§é‡é¢„å®šä¹‰ | æç®€è®¾è®¡ï¼Œä»…ä¸¤ä¸ªæ ¸å¿ƒç»„ä»¶ |
| **é€‚åº”æ€§** | å›ºå®šèƒ½åŠ›è¾¹ç•Œ | æ— é™è‡ªä¸»æ‰©å±• |
| **åˆ›æ–°èƒ½åŠ›** | å—é™äºé¢„è®¾å·¥å…· | è‡ªä¸»åˆ›é€ æ–°å·¥å…· |
| **çŸ¥è¯†ç§¯ç´¯** | é™æ€çŸ¥è¯†åº“ | åŠ¨æ€å­¦ä¹ è¿›åŒ– |
| **è·¨åŸŸå¤ç”¨** | å›°éš¾ï¼Œéœ€é‡æ–°å¼€å‘ | è‡ªåŠ¨è·¨AgentçŸ¥è¯†è½¬ç§» |
| **æ•…éšœæ¢å¤** | äººå·¥å¹²é¢„ | æ™ºèƒ½è‡ªæ„ˆæœºåˆ¶ |
| **ç»´æŠ¤æˆæœ¬** | é«˜ï¼Œéœ€æŒç»­æ›´æ–°é¢„å®šä¹‰ | ä½ï¼Œè‡ªæˆ‘è¿›åŒ–å‡å°‘ç»´æŠ¤ |

#### æˆåŠŸæŒ‡æ ‡é‡æ–°å®šä¹‰

åŸºäºAlitaçš„å“è¶Šè¡¨ç°ï¼ˆGAIAæµ‹è¯•75.15% pass@1ï¼‰ï¼Œæˆ‘ä»¬é‡æ–°åˆ¶å®šæˆåŠŸæŒ‡æ ‡ï¼š

**åˆ›å»ºæ•ˆç‡æŒ‡æ ‡**ï¼š
- MCPåˆ›å»ºæˆåŠŸç‡ > 80% (æå‡è‡ªAlitaåŸºå‡†)
- å¹³å‡åˆ›å»ºæ—¶é—´ < 8åˆ†é’Ÿ (ä¼˜åŒ–è‡ªAlitaçš„å¿«é€Ÿè¿­ä»£)
- é¦–æ¬¡å°è¯•æˆåŠŸç‡ > 70% (å­¦ä¹ Alitaçš„ç²¾å‡†åˆ†æ)

**è´¨é‡ä¿éšœæŒ‡æ ‡**ï¼š
- åˆ›å»ºçš„MCPåŠŸèƒ½æ­£ç¡®æ€§ > 95% (è¶…è¶ŠAlitaæ ‡å‡†)
- ä»£ç è´¨é‡è¯„åˆ† > 85åˆ† (åŸºäºå¼€æºæœ€ä½³å®è·µ)
- è·¨ç¯å¢ƒå…¼å®¹æ€§ > 90% (è‡ªåŠ¨ç¯å¢ƒé€‚é…)

**è‡ªè¿›åŒ–èƒ½åŠ›æŒ‡æ ‡**ï¼š
- çŸ¥è¯†å¤ç”¨ç‡ > 60% (Alitaå¼MCPå¤ç”¨æœºåˆ¶)
- è·¨AgentçŸ¥è¯†è½¬ç§»æˆåŠŸç‡ > 85% (é›†ä½“æ™ºèƒ½æ•ˆåº”)
- æ•…éšœè‡ªæ„ˆæˆåŠŸç‡ > 90% (æ™ºèƒ½æ¢å¤ç­–ç•¥)

**é›†ä½“æ™ºèƒ½æŒ‡æ ‡**ï¼š
- MCPä»“åº“èµ„äº§å¢é•¿ç‡ > 200%/æœˆ
- ç¤¾åŒºè´¡çŒ®çš„MCPè´¨é‡åˆ† > 80åˆ†
- çŸ¥è¯†ä¼ æ’­é€Ÿåº¦ï¼šæ–°MCPè¢«å¤ç”¨æ—¶é—´ < 24å°æ—¶

è¿™ç§åŸºäºAlitaèŒƒå¼çš„MCPæ„é€ æ¨¡å—è®¾è®¡ï¼ŒçœŸæ­£å®ç°äº†ï¼š
- **"Simplicity is the ultimate sophistication"** - æç®€æ¶æ„é©±åŠ¨å¤æ‚èƒ½åŠ›
- **"æœ€å°é¢„å®šä¹‰ï¼Œæœ€å¤§è‡ªè¿›åŒ–"** - ä»å·¥å…·ä½¿ç”¨è€…åˆ°å·¥å…·åˆ›é€ è€…çš„è¿›åŒ–
- **é›†ä½“æ™ºèƒ½** - å•ä¸ªAgentçš„èƒ½åŠ›çªç ´æˆä¸ºæ•´ä¸ªç”Ÿæ€çš„çŸ¥è¯†è´¢å¯Œ

é€šè¿‡è¿™ç§è®¾è®¡ï¼Œæˆ‘ä»¬çš„ç³»ç»Ÿå°†å…·å¤‡çœŸæ­£çš„**è‡ªä¸»åˆ›æ–°èƒ½åŠ›**ï¼Œå¼€å¯Agentè‡ªä¸»åˆ›é€ å·¥å…·çš„æ–°æ—¶ä»£ã€‚


#### ä¸ç°æœ‰æ‰§è¡Œæ²™ç›’Agentçš„é›†æˆè®¾è®¡

**æ ¸å¿ƒç†å¿µï¼šå¢å¼ºç°æœ‰Agentï¼Œè€Œéåˆ›å»ºæ–°Agent**

åŸºäºä½ ä»¬é¡¹ç›®çš„å®é™…æ¶æ„ï¼ŒAlitaçš„MCPManagerAgentå¹¶ä¸æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„æ–°Agentï¼Œè€Œæ˜¯å¯¹ç°æœ‰**æ‰§è¡Œæ²™ç›’ä¸­çš„Agent**çš„èƒ½åŠ›å¢å¼ºã€‚è¿™å®Œå…¨ç¬¦åˆAlitaçš„æç®€è®¾è®¡ç†å¿µã€‚

**ç°æœ‰æ¶æ„åˆ†æ**ï¼š
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        æ™ºèƒ½æ‰§è¡Œæ²™ç›’                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚         ç°æœ‰Agent                   â”‚ â”‚
â”‚  â”‚  â”œâ”€ åœºæ™¯è¯†åˆ«å™¨                      â”‚ â”‚
â”‚  â”‚  â”œâ”€ ä»»åŠ¡åˆ†è§£å™¨                      â”‚ â”‚
â”‚  â”‚  â”œâ”€ Toolkité€‰æ‹©å™¨                   â”‚ â”‚
â”‚  â”‚  â”œâ”€ å·¥å…·é€‰æ‹©å™¨                      â”‚ â”‚
â”‚  â”‚  â””â”€ æ‰§è¡Œåè°ƒå™¨                      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å¢å¼ºåçš„æ¶æ„**ï¼š
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        æ™ºèƒ½æ‰§è¡Œæ²™ç›’                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚    å¢å¼ºçš„Alitaå¼Agent               â”‚ â”‚
â”‚  â”‚  â”œâ”€ åœºæ™¯è¯†åˆ«å™¨ (ç°æœ‰)               â”‚ â”‚
â”‚  â”‚  â”œâ”€ ä»»åŠ¡åˆ†è§£å™¨ (ç°æœ‰)               â”‚ â”‚
â”‚  â”‚  â”œâ”€ Toolkité€‰æ‹©å™¨ (ç°æœ‰)            â”‚ â”‚
â”‚  â”‚  â”œâ”€ å·¥å…·é€‰æ‹©å™¨ (ç°æœ‰)               â”‚ â”‚
â”‚  â”‚  â”œâ”€ æ‰§è¡Œåè°ƒå™¨ (ç°æœ‰)               â”‚ â”‚
â”‚  â”‚  â”‚                                 â”‚ â”‚
â”‚  â”‚  â””â”€ ğŸ†• MCPæ„å»ºèƒ½åŠ›å¢å¼ºæ¨¡å—          â”‚ â”‚
â”‚  â”‚     â”œâ”€ èƒ½åŠ›ç¼ºå£æ£€æµ‹                â”‚ â”‚
â”‚  â”‚     â”œâ”€ MCPéœ€æ±‚åˆ†æ                 â”‚ â”‚
â”‚  â”‚     â”œâ”€ è‡ªä¸»ä»£ç ç”Ÿæˆ                â”‚ â”‚
â”‚  â”‚     â””â”€ MCPæ³¨å†Œé›†æˆ                 â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å…·ä½“é›†æˆå®ç°**ï¼š

```python
class EnhancedSandboxAgent:
    """å¢å¼ºçš„æ‰§è¡Œæ²™ç›’Agent - é›†æˆAlitaå¼MCPæ„å»ºèƒ½åŠ›"""
    
    def __init__(self):
        # === ç°æœ‰ç»„ä»¶ (ä¿æŒä¸å˜) ===
        self.scenario_identifier = ScenarioIdentifier()
        self.task_decomposer = TaskDecomposer()
        self.toolkit_selector = ToolkitSelector()
        self.tool_selector = ToolSelector()
        self.execution_coordinator = ExecutionCoordinator()
        
        # === æ–°å¢ï¼šAlitaå¼MCPæ„å»ºèƒ½åŠ› ===
        self.mcp_builder = AlitaMCPBuilder()
        self.web_agent = WebSearchAgent()  # Alitaçš„ç¬¬äºŒä¸ªæ ¸å¿ƒç»„ä»¶
        
        # çŠ¶æ€ç®¡ç†
        self.current_task_context = None
        self.capability_gaps = []
    
    async def execute_user_query(self, user_query: str) -> ExecutionResult:
        """æ‰§è¡Œç”¨æˆ·æŸ¥è¯¢ - é›†æˆäº†MCPæ„å»ºçš„å®Œæ•´æµç¨‹"""
        
        try:
            # === ç¬¬ä¸€é˜¶æ®µï¼šç°æœ‰æµç¨‹ (ä¿æŒä¸å˜) ===
            
            # 1. åœºæ™¯è¯†åˆ«
            scenario = await self.scenario_identifier.identify(user_query)
            
            # 2. ä»»åŠ¡åˆ†è§£
            tasks = await self.task_decomposer.decompose(user_query, scenario)
            
            # 3. Toolkité€‰æ‹©
            selected_toolkits = await self.toolkit_selector.select(tasks, scenario)
            
            # 4. å·¥å…·é€‰æ‹©
            selected_tools = await self.tool_selector.select(tasks, selected_toolkits)
            
            # === ç¬¬äºŒé˜¶æ®µï¼šæ–°å¢çš„èƒ½åŠ›ç¼ºå£æ£€æµ‹ ===
            
            # 5. æ£€æµ‹èƒ½åŠ›ç¼ºå£ (æ–°å¢)
            capability_assessment = await self._assess_capability_sufficiency(
                user_query=user_query,
                tasks=tasks,
                available_tools=selected_tools
            )
            
            if capability_assessment.sufficient:
                # ç°æœ‰å·¥å…·è¶³å¤Ÿ - ç›´æ¥æ‰§è¡Œ
                return await self.execution_coordinator.execute(
                    tasks=tasks,
                    tools=selected_tools
                )
            else:
                # å­˜åœ¨èƒ½åŠ›ç¼ºå£ - è§¦å‘Alitaå¼MCPæ„å»º
                enhanced_tools = await self._handle_capability_gaps(
                    user_query=user_query,
                    tasks=tasks,
                    existing_tools=selected_tools,
                    capability_gaps=capability_assessment.gaps
                )
                
                # ä½¿ç”¨å¢å¼ºåçš„å·¥å…·é›†æ‰§è¡Œä»»åŠ¡
                return await self.execution_coordinator.execute(
                    tasks=tasks,
                    tools=enhanced_tools
                )
                
        except Exception as e:
            # å¼‚å¸¸å¤„ç†å’Œå›é€€ç­–ç•¥
            return await self._handle_execution_failure(user_query, str(e))

    async def _assess_capability_sufficiency(self, 
                                           user_query: str,
                                           tasks: List[Task],
                                           available_tools: List[Tool]) -> CapabilityAssessment:
        """è¯„ä¼°ç°æœ‰å·¥å…·çš„èƒ½åŠ›å……è¶³æ€§"""
        
        assessment_prompt = f"""
        ä½œä¸ºæ‰§è¡Œæ²™ç›’ä¸­çš„Agentï¼Œæˆ‘éœ€è¦è¯„ä¼°ç°æœ‰å·¥å…·æ˜¯å¦è¶³ä»¥å®Œæˆç”¨æˆ·ä»»åŠ¡ã€‚

        ç”¨æˆ·æŸ¥è¯¢: {user_query}
        åˆ†è§£ä»»åŠ¡: {[task.description for task in tasks]}
        å¯ç”¨å·¥å…·: {[tool.name + ': ' + tool.description for tool in available_tools]}

        è¯·åˆ†æï¼š
        1. æ¯ä¸ªå­ä»»åŠ¡æ˜¯å¦æœ‰å¯¹åº”çš„å·¥å…·èƒ½å¤Ÿå¤„ç†ï¼Ÿ
        2. å·¥å…·çš„èƒ½åŠ›æ˜¯å¦æ»¡è¶³ä»»åŠ¡çš„å…·ä½“è¦æ±‚ï¼Ÿ
        3. æ˜¯å¦å­˜åœ¨åŠŸèƒ½ç¼ºå£æˆ–æ€§èƒ½ç“¶é¢ˆï¼Ÿ

        å¦‚æœå­˜åœ¨ç¼ºå£ï¼Œè¯·è¯¦ç»†æè¿°ï¼š
        - ç¼ºå¤±çš„å…·ä½“åŠŸèƒ½
        - å¯¹åº”çš„æŠ€æœ¯éœ€æ±‚
        - ä¼˜å…ˆçº§è¯„ä¼°
        """
        
        response = await self.llm_client.analyze(assessment_prompt)
        
        return CapabilityAssessment(
            sufficient=response.capability_sufficient,
            gaps=response.identified_gaps,
            confidence_score=response.confidence,
            reasoning=response.analysis_reasoning
        )

    async def _handle_capability_gaps(self,
                                    user_query: str,
                                    tasks: List[Task],
                                    existing_tools: List[Tool],
                                    capability_gaps: List[CapabilityGap]) -> List[Tool]:
        """å¤„ç†èƒ½åŠ›ç¼ºå£ - Alitaå¼MCPæ„å»ºçš„æ ¸å¿ƒé€»è¾‘"""
        
        enhanced_tools = existing_tools.copy()
        
        for gap in capability_gaps:
            try:
                # å°è¯•ä»MCPä»“åº“ä¸­æ‰¾åˆ°ç°æœ‰è§£å†³æ–¹æ¡ˆ
                existing_mcp = await self.mcp_builder.find_existing_solution(gap)
                
                if existing_mcp:
                    # å¤ç”¨ç°æœ‰MCP
                    tool = await self._integrate_mcp_as_tool(existing_mcp)
                    enhanced_tools.append(tool)
                    continue
                
                # æ²¡æœ‰ç°æœ‰è§£å†³æ–¹æ¡ˆ - åˆ›å»ºæ–°MCP
                print(f"ğŸ”§ æ£€æµ‹åˆ°èƒ½åŠ›ç¼ºå£ï¼Œå¼€å§‹è‡ªä¸»æ„å»ºMCP: {gap.description}")
                
                # Alitaå¼MCPåˆ›å»ºæµç¨‹
                mcp_requirement = MCPRequirement(
                    description=gap.description,
                    technical_specs=gap.technical_requirements,
                    priority=gap.priority,
                    context=user_query
                )
                
                # ç½‘ç»œæœç´¢ç›¸å…³èµ„æº
                search_results = await self.web_agent.search_open_source_resources(
                    query=gap.search_keywords,
                    context=user_query
                )
                
                # è‡ªä¸»ç”ŸæˆMCP
                new_mcp = await self.mcp_builder.create_mcp(
                    requirement=mcp_requirement,
                    external_resources=search_results
                )
                
                if new_mcp.creation_successful:
                    # æ³¨å†Œåˆ°å·¥å…·åº“
                    await self._register_new_mcp(new_mcp)
                    
                    # é›†æˆä¸ºå¯ç”¨å·¥å…·
                    tool = await self._integrate_mcp_as_tool(new_mcp)
                    enhanced_tools.append(tool)
                    
                    print(f"âœ… MCPæ„å»ºæˆåŠŸ: {new_mcp.name}")
                else:
                    print(f"âŒ MCPæ„å»ºå¤±è´¥: {gap.description}")
                    # è®°å½•å¤±è´¥ï¼Œä½†ç»§ç»­å¤„ç†å…¶ä»–ç¼ºå£
                    
            except Exception as e:
                print(f"âš ï¸ å¤„ç†èƒ½åŠ›ç¼ºå£æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")
                # ç»§ç»­å¤„ç†å…¶ä»–ç¼ºå£ï¼Œä¸ä¸­æ–­æ•´ä¸ªæµç¨‹
                continue
        
        return enhanced_tools

    async def _integrate_mcp_as_tool(self, mcp_asset: MCPAsset) -> Tool:
        """å°†MCPèµ„äº§é›†æˆä¸ºå¯è°ƒç”¨çš„å·¥å…·"""
        
        return Tool(
            id=f"mcp_{mcp_asset.id}",
            name=mcp_asset.name,
            description=mcp_asset.description,
            parameters=mcp_asset.parameters,
            execution_method="mcp_server",
            mcp_config={
                "server_path": mcp_asset.server_path,
                "environment": mcp_asset.environment_config,
                "capabilities": mcp_asset.capabilities
            },
            created_by="alita_auto_builder",
            effectiveness_score=mcp_asset.effectiveness_score
        )
```

**æ ¸å¿ƒä¼˜åŠ¿**ï¼š

1. **ğŸ”„ æ— ç¼é›†æˆ**ï¼šMCPæ„å»ºèƒ½åŠ›ç›´æ¥é›†æˆåˆ°ç°æœ‰çš„Agentæ‰§è¡Œæµç¨‹ä¸­
2. **ğŸ“ˆ æ¸è¿›å¢å¼º**ï¼šç°æœ‰åŠŸèƒ½ä¿æŒä¸å˜ï¼Œåªæ˜¯åœ¨éœ€è¦æ—¶å¢åŠ MCPæ„å»º
3. **âš¡ å®æ—¶å“åº”**ï¼šåœ¨ä»»åŠ¡æ‰§è¡Œè¿‡ç¨‹ä¸­åŠ¨æ€å‘ç°å¹¶è§£å†³èƒ½åŠ›ç¼ºå£
4. **ğŸ¯ ä¸Šä¸‹æ–‡æ„ŸçŸ¥**ï¼šåŸºäºå…·ä½“ä»»åŠ¡éœ€æ±‚åˆ›å»ºé’ˆå¯¹æ€§çš„MCP

**æ‰§è¡Œæµç¨‹ç¤ºä¾‹**ï¼š

```
ç”¨æˆ·æŸ¥è¯¢: "å¸®æˆ‘åˆ†æè¿™ä¸ªExcelæ–‡ä»¶ä¸­çš„é”€å”®æ•°æ®ï¼Œç”Ÿæˆå¯è§†åŒ–å›¾è¡¨"

1. åœºæ™¯è¯†åˆ« âœ… â†’ æ•°æ®åˆ†æåœºæ™¯
2. ä»»åŠ¡åˆ†è§£ âœ… â†’ [è¯»å–Excel, æ•°æ®å¤„ç†, ç”Ÿæˆå›¾è¡¨]
3. å·¥å…·é€‰æ‹© âœ… â†’ [pandas_reader, basic_analyzer]
4. èƒ½åŠ›è¯„ä¼° âŒ â†’ ç¼ºå°‘é«˜çº§å¯è§†åŒ–èƒ½åŠ›

5. MCPæ„å»º ğŸ”§:
   - æœç´¢matplotlib/seabornèµ„æº
   - ç”Ÿæˆå¯è§†åŒ–MCP Server
   - éªŒè¯å¹¶æ³¨å†Œæ–°å·¥å…·

6. ä»»åŠ¡æ‰§è¡Œ âœ… â†’ ä½¿ç”¨åŸæœ‰å·¥å…· + æ–°å»ºMCPå®Œæˆä»»åŠ¡
```

**å›ç­”ä½ çš„æ ¸å¿ƒé—®é¢˜**ï¼š

- **MCPManagerAgentå°±æ˜¯ä½ ä»¬ç°æœ‰çš„æ‰§è¡Œæ²™ç›’Agent** âœ…
- **ä¸éœ€è¦é¢å¤–çš„å¤§æ¨¡å‹** âœ…  
- **åªéœ€è¦å¢å¼ºç°æœ‰Agentçš„èƒ½åŠ›** âœ…
- **ä¿æŒAlitaçš„æç®€è®¾è®¡ç†å¿µ** âœ…

è¿™æ ·çš„è®¾è®¡æ—¢å¤ç”¨äº†ç°æœ‰çš„æˆç†Ÿæ¶æ„ï¼Œåˆè·å¾—äº†Alitaçš„è‡ªä¸»åˆ›æ–°èƒ½åŠ›ï¼Œæ˜¯æœ€ä¼˜çš„é›†æˆæ–¹æ¡ˆï¼

# migration/progressive_switchover.py
class ProgressiveSwitchover:
    """æ¸è¿›å¼åˆ‡æ¢æ§åˆ¶å™¨"""
    
    def __init__(self):
        self.switch_ratio = 0.0  # æ–°ç³»ç»Ÿæµé‡æ¯”ä¾‹
        self.health_monitor = HealthMonitor()
        self.fallback_manager = FallbackManager()
    
    async def gradual_switchover(self):
        """æ¸è¿›å¼æµé‡åˆ‡æ¢"""
        
        switch_plan = [
            (0.1, "10% traffic to new system"),
            (0.3, "30% traffic validation"),
            (0.5, "Half traffic split testing"),
            (0.8, "80% traffic migration"),
            (1.0, "Full migration complete")
        ]
        
        for ratio, description in switch_plan:
            logger.info(f"Switching to ratio {ratio}: {description}")
            
            # æ›´æ–°æµé‡åˆ†é…
            await self._update_traffic_ratio(ratio)
            
            # ç›‘æ§ç³»ç»Ÿå¥åº·çŠ¶æ€
            await asyncio.sleep(300)  # ç­‰å¾…5åˆ†é’Ÿè§‚å¯Ÿ
            
            health_status = await self.health_monitor.check_system_health()
            
            if not health_status.healthy:
                logger.error(f"Health check failed at ratio {ratio}, rolling back")
                await self.fallback_manager.rollback_to_ratio(self.switch_ratio)
                break
            
            self.switch_ratio = ratio
            logger.info(f"Successfully switched to ratio {ratio}")
        
        return self.switch_ratio == 1.0
    
    async def _update_traffic_ratio(self, ratio: float):
        """æ›´æ–°æµé‡åˆ†é…æ¯”ä¾‹"""
        # æ›´æ–°è´Ÿè½½å‡è¡¡å™¨é…ç½®
        # æ›´æ–°Runtimeè·¯ç”±è§„åˆ™
        # æ›´æ–°ç›‘æ§æŒ‡æ ‡
        pass

class HealthMonitor:
    """ç³»ç»Ÿå¥åº·ç›‘æ§"""
    
    async def check_system_health(self) -> HealthStatus:
        """æ£€æŸ¥ç³»ç»Ÿæ•´ä½“å¥åº·çŠ¶æ€"""
        
        checks = [
            self._check_response_time(),
            self._check_error_rate(), 
            self._check_tool_success_rate(),
            self._check_agent_decision_quality()
        ]
        
        results = await asyncio.gather(*checks)
        
        overall_healthy = all(result.healthy for result in results)
        
        return HealthStatus(
            healthy=overall_healthy,
            checks=results,
            timestamp=datetime.utcnow()
        )
```

---

## 8. æ­¥éª¤çº§è½¨è¿¹ä¸èƒ½åŠ›è‡ªåŠ¨æ¼”åŒ–

### 8.1 æ­¥éª¤çº§è½¨è¿¹è®°å½•ç³»ç»Ÿ

```python
# trajectory/step_level_recorder.py
class StepLevelTrajectorySystem:
    """æ­¥éª¤çº§è½¨è¿¹è®°å½•ç³»ç»Ÿ - è®°å½•Agentå†³ç­–çš„æ¯ä¸ªç»†èŠ‚"""
    
    def __init__(self, storage_backend: TrajectoryStorage):
        self.storage = storage_backend
        self.analytics_engine = TrajectoryAnalyticsEngine()
        self.evolution_engine = CapabilityEvolutionEngine()
    
    async def record_agent_trajectory(self, execution_context: ExecutionContext) -> TrajectoryID:
        """è®°å½•Agentå®Œæ•´æ‰§è¡Œè½¨è¿¹"""
        
        trajectory_id = self._generate_trajectory_id()
        
        # è®°å½•è½¨è¿¹å…ƒæ•°æ®
        await self.storage.create_trajectory(TrajectoryMetadata(
            id=trajectory_id,
            user_query=execution_context.query,
            start_time=execution_context.start_time,
            agent_version=execution_context.agent_version,
            llm_model=execution_context.llm_model
        ))
        
        return trajectory_id
    
    async def record_scenario_identification(self, trajectory_id: TrajectoryID, 
                                           scenario_result: ScenarioIdentificationResult):
        """è®°å½•åœºæ™¯è¯†åˆ«æ­¥éª¤"""
        step = TrajectoryStep(
            trajectory_id=trajectory_id,
            step_type="scenario_identification",
            step_index=1,
            input_data={
                "user_query": scenario_result.input_query,
                "analysis_method": scenario_result.analysis_method
            },
            output_data={
                "identified_scenario": scenario_result.scenario_type,
                "confidence_score": scenario_result.confidence,
                "alternative_scenarios": scenario_result.alternatives
            },
            execution_time=scenario_result.execution_time,
            success=True,
            timestamp=datetime.utcnow()
        )
        
        await self.storage.store_step(step)
    
    async def record_toolkit_selection(self, trajectory_id: TrajectoryID,
                                     selection_result: ToolkitSelectionResult):
        """è®°å½•Toolkité€‰æ‹©æ­¥éª¤"""
        step = TrajectoryStep(
            trajectory_id=trajectory_id,
            step_type="toolkit_selection",
            step_index=selection_result.step_index,
            input_data={
                "subtask_description": selection_result.subtask.description,
                "available_toolkits": [tk.name for tk in selection_result.available_toolkits],
                "selection_criteria": selection_result.selection_criteria
            },
            output_data={
                "selected_toolkit": selection_result.selected_toolkit.name,
                "selection_reasoning": selection_result.llm_reasoning,
                "confidence_score": selection_result.confidence
            },
            llm_interaction={
                "prompt": selection_result.llm_prompt,
                "response": selection_result.llm_response,
                "model": selection_result.llm_model
            },
            execution_time=selection_result.execution_time,
            success=True,
            timestamp=datetime.utcnow()
        )
        
        await self.storage.store_step(step)
    
    async def record_tool_selection(self, trajectory_id: TrajectoryID,
                                  tool_selection: ToolSelectionResult):
        """è®°å½•å…·ä½“å·¥å…·é€‰æ‹©æ­¥éª¤"""
        step = TrajectoryStep(
            trajectory_id=trajectory_id,
            step_type="tool_selection",
            step_index=tool_selection.step_index,
            input_data={
                "toolkit_name": tool_selection.toolkit_name,
                "available_tools": [tool.name for tool in tool_selection.available_tools],
                "task_requirements": tool_selection.task_requirements
            },
            output_data={
                "selected_tool": tool_selection.selected_tool.name,
                "selection_reasoning": tool_selection.reasoning,
                "execution_plan": tool_selection.execution_plan
            },
            llm_interaction={
                "prompt": tool_selection.llm_prompt,
                "response": tool_selection.llm_response
            },
            execution_time=tool_selection.execution_time,
            success=True,
            timestamp=datetime.utcnow()
        )
        
        await self.storage.store_step(step)
    
    async def record_tool_execution(self, trajectory_id: TrajectoryID,
                                  execution_result: ToolExecutionResult):
        """è®°å½•å·¥å…·æ‰§è¡Œæ­¥éª¤"""
        step = TrajectoryStep(
            trajectory_id=trajectory_id,
            step_type="tool_execution",
            step_index=execution_result.step_index,
            input_data={
                "tool_name": execution_result.tool_name,
                "action": execution_result.action,
                "parameters": execution_result.parameters,
                "tool_type": execution_result.tool_type  # function vs mcp_server
            },
            output_data={
                "execution_result": execution_result.result_data,
                "success": execution_result.success,
                "error_message": execution_result.error_message
            },
            performance_metrics={
                "execution_time": execution_result.execution_time,
                "memory_usage": execution_result.memory_usage,
                "network_latency": execution_result.network_latency
            },
            execution_time=execution_result.execution_time,
            success=execution_result.success,
            timestamp=datetime.utcnow()
        )
        
        await self.storage.store_step(step)
    
    async def finalize_trajectory(self, trajectory_id: TrajectoryID,
                                final_result: AgentExecutionResult):
        """å®Œæˆè½¨è¿¹è®°å½•ï¼Œè§¦å‘åˆ†æå’Œæ¼”åŒ–"""
        
        # æ›´æ–°è½¨è¿¹çŠ¶æ€
        await self.storage.finalize_trajectory(trajectory_id, final_result)
        
        # å¼‚æ­¥è§¦å‘è½¨è¿¹åˆ†æ
        asyncio.create_task(self._analyze_trajectory(trajectory_id))
        
        # å¼‚æ­¥è§¦å‘èƒ½åŠ›æ¼”åŒ–
        asyncio.create_task(self._evolve_capabilities(trajectory_id))
    
    async def _analyze_trajectory(self, trajectory_id: TrajectoryID):
        """åˆ†æè½¨è¿¹è´¨é‡å’Œæ¨¡å¼"""
        trajectory = await self.storage.get_complete_trajectory(trajectory_id)
        analysis_result = await self.analytics_engine.analyze_trajectory(trajectory)
        
        # å­˜å‚¨åˆ†æç»“æœ
        await self.storage.store_trajectory_analysis(trajectory_id, analysis_result)
    
    async def _evolve_capabilities(self, trajectory_id: TrajectoryID):
        """åŸºäºè½¨è¿¹æ¼”åŒ–å·¥å…·èƒ½åŠ›"""
        trajectory = await self.storage.get_complete_trajectory(trajectory_id)
        await self.evolution_engine.evolve_from_trajectory(trajectory)

class CapabilityEvolutionEngine:
    """å·¥å…·èƒ½åŠ›è‡ªåŠ¨æ¼”åŒ–å¼•æ“"""
    
    def __init__(self, tool_library: UnifiedToolLibrary):
        self.tool_library = tool_library
        self.pattern_analyzer = TrajectoryPatternAnalyzer()
        self.description_optimizer = DescriptionOptimizer()
        self.classification_learner = ToolClassificationLearner()
    
    async def evolve_from_trajectory(self, trajectory: CompleteTrajectory):
        """ä»è½¨è¿¹ä¸­å­¦ä¹ å¹¶æ¼”åŒ–å·¥å…·èƒ½åŠ›"""
        
        # ========== 1. åˆ†æè½¨è¿¹æ¨¡å¼ ==========
        patterns = await self.pattern_analyzer.extract_patterns(trajectory)
        
        # ========== 2. ä¼˜åŒ–å·¥å…·æè¿° ==========
        await self._optimize_tool_descriptions(trajectory, patterns)
        
        # ========== 3. æ”¹è¿›å·¥å…·åˆ†ç±» ==========
        await self._improve_tool_classification(trajectory, patterns)
        
        # ========== 4. æ›´æ–°åœºæ™¯æ˜ å°„ ==========
        await self._update_scenario_mapping(trajectory, patterns)
        
        # ========== 5. å­¦ä¹ å·¥å…·ç»„åˆæ¨¡å¼ ==========
        await self._learn_tool_combinations(trajectory, patterns)
    
    async def _optimize_tool_descriptions(self, trajectory: CompleteTrajectory, 
                                        patterns: TrajectoryPatterns):
        """ä¼˜åŒ–å·¥å…·æè¿°çš„LLMå‹å¥½æ€§"""
        
        for step in trajectory.tool_execution_steps:
            tool_id = step.input_data["tool_name"]
            
            # åˆ†æå·¥å…·ä½¿ç”¨ä¸Šä¸‹æ–‡
            usage_context = self._extract_usage_context(step, trajectory)
            
            # åˆ†æå·¥å…·æ‰§è¡Œæ•ˆæœ
            effectiveness = self._calculate_tool_effectiveness(step)
            
            # å¦‚æœå·¥å…·è¡¨ç°è‰¯å¥½ï¼Œæå–æˆåŠŸæ¨¡å¼
            if effectiveness.score > 0.8:
                success_pattern = SuccessPattern(
                    tool_id=tool_id,
                    context=usage_context,
                    parameters=step.input_data["parameters"],
                    result_quality=effectiveness.score
                )
                
                # æ›´æ–°å·¥å…·æè¿°ï¼Œçªå‡ºæˆåŠŸä½¿ç”¨åœºæ™¯
                await self.description_optimizer.enhance_description(
                    tool_id, success_pattern
                )
            
            # å¦‚æœå·¥å…·å¤±è´¥ï¼Œåˆ†æå¤±è´¥åŸå› 
            elif effectiveness.score < 0.3:
                failure_analysis = FailureAnalysis(
                    tool_id=tool_id,
                    error_type=step.output_data.get("error_type"),
                    context=usage_context,
                    root_cause=self._analyze_failure_cause(step)
                )
                
                # æ›´æ–°å·¥å…·æè¿°ï¼Œæ·»åŠ æ³¨æ„äº‹é¡¹
                await self.description_optimizer.add_usage_warning(
                    tool_id, failure_analysis
                )
    
    async def _improve_tool_classification(self, trajectory: CompleteTrajectory,
                                         patterns: TrajectoryPatterns):
        """æ”¹è¿›å·¥å…·çš„Toolkitåˆ†ç±»"""
        
        # åˆ†æå·¥å…·çš„å®é™…ä½¿ç”¨åœºæ™¯
        for step in trajectory.tool_execution_steps:
            tool_id = step.input_data["tool_name"]
            actual_scenario = trajectory.metadata.identified_scenario
            
            # è·å–å½“å‰å·¥å…·çš„åˆ†ç±»
            current_toolkit = await self.tool_library.get_tool_toolkit(tool_id)
            
            # åˆ†ææ˜¯å¦éœ€è¦é‡æ–°åˆ†ç±»
            classification_analysis = await self.classification_learner.analyze_classification(
                tool_id, actual_scenario, step.execution_context
            )
            
            if classification_analysis.should_reclassify:
                # å»ºè®®é‡æ–°åˆ†ç±»
                await self.tool_library.suggest_reclassification(
                    tool_id, 
                    current_toolkit, 
                    classification_analysis.suggested_toolkit,
                    classification_analysis.confidence
                )
    
    async def _learn_tool_combinations(self, trajectory: CompleteTrajectory,
                                     patterns: TrajectoryPatterns):
        """å­¦ä¹ æœ‰æ•ˆçš„å·¥å…·ç»„åˆæ¨¡å¼"""
        
        # æå–å·¥å…·ä½¿ç”¨åºåˆ—
        tool_sequence = self._extract_tool_sequence(trajectory)
        
        if len(tool_sequence) > 1:
            # åˆ†æå·¥å…·ç»„åˆçš„æ•ˆæœ
            combination_effectiveness = self._evaluate_combination_effectiveness(
                tool_sequence, trajectory.final_result
            )
            
            if combination_effectiveness.score > 0.8:
                # è®°å½•æˆåŠŸçš„å·¥å…·ç»„åˆæ¨¡å¼
                combination_pattern = ToolCombinationPattern(
                    scenario=trajectory.metadata.identified_scenario,
                    tool_sequence=tool_sequence,
                    effectiveness=combination_effectiveness.score,
                    context=trajectory.metadata.user_query
                )
                
                # æ›´æ–°Toolkitæ¨èç­–ç•¥
                await self.tool_library.update_combination_patterns(combination_pattern)
    
    def _extract_usage_context(self, step: TrajectoryStep, 
                             trajectory: CompleteTrajectory) -> UsageContext:
        """æå–å·¥å…·ä½¿ç”¨ä¸Šä¸‹æ–‡"""
        return UsageContext(
            scenario=trajectory.metadata.identified_scenario,
            user_intent=trajectory.metadata.user_query,
            preceding_tools=[s.input_data["tool_name"] for s in trajectory.steps[:step.step_index-1]],
            task_complexity=self._estimate_task_complexity(trajectory),
            success_outcome=step.success
        )

class DynamicDescriptionEngine:
    """åŠ¨æ€å·¥å…·æè¿°ç”Ÿæˆå¼•æ“"""
    
    def __init__(self):
        self.llm_client = LLMClient()
        self.description_templates = DescriptionTemplateManager()
        self.usage_analytics = ToolUsageAnalytics()
    
    async def generate_dynamic_description(self, tool_id: str, 
                                         format_type: str = "llm") -> str:
        """ç”ŸæˆåŠ¨æ€çš„å·¥å…·æè¿°"""
        
        # è·å–å·¥å…·åŸºç¡€ä¿¡æ¯
        tool_info = await self._get_tool_base_info(tool_id)
        
        # è·å–ä½¿ç”¨ç»Ÿè®¡æ•°æ®
        usage_stats = await self.usage_analytics.get_tool_stats(tool_id)
        
        # è·å–æœ€ä½³å®è·µæ¡ˆä¾‹
        best_practices = await self._get_best_practices(tool_id)
        
        # è·å–å¸¸è§é”™è¯¯å’Œæ³¨æ„äº‹é¡¹
        common_issues = await self._get_common_issues(tool_id)
        
        if format_type == "llm":
            return await self._generate_llm_friendly_description(
                tool_info, usage_stats, best_practices, common_issues
            )
        elif format_type == "json":
            return await self._generate_structured_description(
                tool_info, usage_stats, best_practices, common_issues
            )
        else:
            return tool_info.basic_description
    
    async def _generate_llm_friendly_description(self, tool_info: ToolInfo,
                                               usage_stats: ToolUsageStats,
                                               best_practices: List[BestPractice],
                                               common_issues: List[CommonIssue]) -> str:
        """ç”ŸæˆLLMå‹å¥½çš„å·¥å…·æè¿°"""
        
        prompt = f"""
        æ ¹æ®ä»¥ä¸‹ä¿¡æ¯ï¼Œç”Ÿæˆä¸€ä¸ªLLMå‹å¥½çš„å·¥å…·æè¿°ï¼Œå¸®åŠ©AI Agentæ›´å¥½åœ°ç†è§£å’Œä½¿ç”¨è¿™ä¸ªå·¥å…·ï¼š

        å·¥å…·åŸºç¡€ä¿¡æ¯ï¼š
        - åç§°ï¼š{tool_info.name}
        - ç±»å‹ï¼š{tool_info.tool_type}
        - åŸºç¡€æè¿°ï¼š{tool_info.basic_description}

        ä½¿ç”¨ç»Ÿè®¡ï¼ˆæœ€è¿‘30å¤©ï¼‰ï¼š
        - æ€»ä½¿ç”¨æ¬¡æ•°ï¼š{usage_stats.total_usage}
        - æˆåŠŸç‡ï¼š{usage_stats.success_rate:.2%}
        - å¹³å‡æ‰§è¡Œæ—¶é—´ï¼š{usage_stats.avg_execution_time:.2f}ç§’
        - æœ€å¸¸ç”¨åœºæ™¯ï¼š{', '.join(usage_stats.top_scenarios)}

        æœ€ä½³å®è·µæ¡ˆä¾‹ï¼š
        {self._format_best_practices(best_practices)}

        å¸¸è§é—®é¢˜å’Œæ³¨æ„äº‹é¡¹ï¼š
        {self._format_common_issues(common_issues)}

        è¯·ç”Ÿæˆä¸€ä¸ªç»“æ„åŒ–çš„å·¥å…·æè¿°ï¼ŒåŒ…å«ï¼š
        1. å·¥å…·åŠŸèƒ½æ¦‚è¿°
        2. ä¸»è¦ä½¿ç”¨åœºæ™¯
        3. å‚æ•°è¯´æ˜å’Œç¤ºä¾‹
        4. æœ€ä½³å®è·µå»ºè®®
        5. æ³¨æ„äº‹é¡¹å’Œé”™è¯¯é¢„é˜²

        æè¿°åº”è¯¥å…·ä½“ã€å‡†ç¡®ï¼Œå¸®åŠ©AI Agentåšå‡ºæ›´å¥½çš„å·¥å…·é€‰æ‹©å’Œä½¿ç”¨å†³ç­–ã€‚
        """
        
        response = await self.llm_client.generate(prompt)
        return response.strip()
```

### 8.2 å·¥å…·èƒ½åŠ›è‡ªåŠ¨æ¼”åŒ–æµç¨‹

```mermaid
graph TB
    A[Agentæ‰§è¡Œè½¨è¿¹] --> B[æ­¥éª¤çº§è½¨è¿¹è®°å½•]
    B --> C[è½¨è¿¹æ¨¡å¼åˆ†æ]
    C --> D[å·¥å…·ä½¿ç”¨æ•ˆæœè¯„ä¼°]
    D --> E{å·¥å…·è¡¨ç°å¦‚ä½•?}
    E -->|ä¼˜ç§€| F[æå–æˆåŠŸæ¨¡å¼]
    E -->|ä¸€èˆ¬| G[ä¿æŒç°çŠ¶]
    E -->|ç³Ÿç³•| H[åˆ†æå¤±è´¥åŸå› ]
    F --> I[ä¼˜åŒ–å·¥å…·æè¿°]
    H --> J[æ·»åŠ ä½¿ç”¨è­¦å‘Š]
    I --> K[æ›´æ–°åœºæ™¯æ˜ å°„]
    J --> K
    K --> L[å­¦ä¹ å·¥å…·ç»„åˆ]
    L --> M[æ›´æ–°Toolkitåˆ†ç±»]
    M --> N[åé¦ˆåˆ°å·¥å…·åº“]
    N --> O[æ–°è½¨è¿¹éªŒè¯æ”¹è¿›æ•ˆæœ]
    O --> A
```

### 8.3 è½¨è¿¹æ•°æ®å­˜å‚¨è®¾è®¡

```sql
-- è½¨è¿¹ä¸»è¡¨
CREATE TABLE agent_trajectories (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    trajectory_id VARCHAR(64) UNIQUE NOT NULL,
    user_query TEXT NOT NULL,
    identified_scenario VARCHAR(100),
    agent_version VARCHAR(50),
    llm_model VARCHAR(50),
    start_time TIMESTAMP NOT NULL,
    end_time TIMESTAMP,
    final_success BOOLEAN,
    total_steps INT DEFAULT 0,
    total_execution_time DECIMAL(10,3),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_trajectory_id (trajectory_id),
    INDEX idx_scenario (identified_scenario),
    INDEX idx_success (final_success),
    INDEX idx_start_time (start_time)
);

-- æ­¥éª¤è¯¦æƒ…è¡¨
CREATE TABLE trajectory_steps (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    trajectory_id VARCHAR(64) NOT NULL,
    step_type ENUM('scenario_identification', 'task_decomposition', 
                   'toolkit_selection', 'tool_selection', 'tool_execution') NOT NULL,
    step_index INT NOT NULL,
    input_data JSON NOT NULL,
    output_data JSON NOT NULL,
    llm_interaction JSON,
    performance_metrics JSON,
    execution_time DECIMAL(10,3),
    success BOOLEAN NOT NULL,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (trajectory_id) REFERENCES agent_trajectories(trajectory_id),
    INDEX idx_trajectory_step (trajectory_id, step_index),
    INDEX idx_step_type (step_type),
    INDEX idx_success (success)
);

-- å·¥å…·ä½¿ç”¨æ•ˆæœè¡¨
CREATE TABLE tool_effectiveness_metrics (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    tool_id VARCHAR(100) NOT NULL,
    scenario_type VARCHAR(100) NOT NULL,
    usage_count BIGINT DEFAULT 0,
    success_count BIGINT DEFAULT 0,
    total_execution_time DECIMAL(12,3) DEFAULT 0,
    avg_effectiveness_score DECIMAL(3,2) DEFAULT 0.5,
    last_used_at TIMESTAMP,
    last_updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    UNIQUE KEY uk_tool_scenario (tool_id, scenario_type),
    INDEX idx_effectiveness (avg_effectiveness_score DESC),
    INDEX idx_usage_count (usage_count DESC)
);
```

---

## 8.4 MCP Server è¿œç¨‹å·¥å…·æœåŠ¡

### 8.4.1 æ ¸å¿ƒç»„ä»¶

**MCP Server Manager**: è´Ÿè´£ç®¡ç†è¿œç¨‹ MCP Server çš„ç”Ÿå‘½å‘¨æœŸ
- å¯åŠ¨ã€åœæ­¢ã€å¥åº·æ£€æŸ¥
- è¿æ¥æ± ç®¡ç†å’Œè´Ÿè½½å‡è¡¡
- å¼‚å¸¸æ¢å¤å’Œæ•…éšœè½¬ç§»

**MCP Protocol Adapter**: å°è£… MCP åè®®é€šä¿¡ç»†èŠ‚
- æ ‡å‡†åŒ–è¯·æ±‚å“åº”æ ¼å¼
- å¼‚æ­¥é€šä¿¡å’Œè¶…æ—¶å¤„ç†
- åè®®ç‰ˆæœ¬å…¼å®¹æ€§ç®¡ç†

**Remote Tool Proxy**: å°†è¿œç¨‹å·¥å…·åŒ…è£…ä¸ºæœ¬åœ°æ¥å£
- é€æ˜çš„è¿œç¨‹è°ƒç”¨å°è£…
- æœ¬åœ°ç¼“å­˜å’Œæ€§èƒ½ä¼˜åŒ–
- é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶

### 8.4.2 å®æ–½ç­–ç•¥

1. **æ¸è¿›å¼è¿ç§»**: ç°æœ‰å·¥å…·é€æ­¥è¿ç§»è‡³ MCP Server
2. **æ€§èƒ½ä¼˜åŒ–**: è¿æ¥å¤ç”¨ã€è¯·æ±‚æ‰¹å¤„ç†ã€ç»“æœç¼“å­˜
3. **ç›‘æ§å‘Šè­¦**: å…¨é“¾è·¯ç›‘æ§ã€æ€§èƒ½æŒ‡æ ‡ã€SLAä¿éšœ
4. **å®‰å…¨ç­–ç•¥**: è®¤è¯æˆæƒã€ç½‘ç»œéš”ç¦»ã€æ•°æ®åŠ å¯†

---

## 8.5 åŠ¨æ€MCP Serverè‡ªåŠ¨æ„å»ºæ¨¡å— ğŸš€

### 8.5.1 æ¨¡å—æ¦‚è¿°ä¸è®¾è®¡ç†å¿µ

åŸºäºAlitaè®ºæ–‡çš„"æœ€å°é¢„å®šä¹‰ï¼Œæœ€å¤§è‡ªè¿›åŒ–"æ ¸å¿ƒç†å¿µï¼Œå½“Agentåœ¨æ™ºèƒ½å‘ç°è¿‡ç¨‹ä¸­å‘ç°**ç°æœ‰å·¥å…·åº“æ— æ³•æ»¡è¶³ç”¨æˆ·éœ€æ±‚**æ—¶ï¼Œç³»ç»Ÿå°†è‡ªåŠ¨å¯åŠ¨**åŠ¨æ€MCP Serveræ„å»ºæµç¨‹**ã€‚è¿™ä¸ªæ¨¡å—ä»£è¡¨äº†ä»"å·¥å…·ä½¿ç”¨è€…"åˆ°"å·¥å…·åˆ›é€ è€…"çš„é©å‘½æ€§é£è·ƒï¼Œä½¿Agentå…·å¤‡çœŸæ­£çš„è‡ªä¸»æ‰©å±•èƒ½åŠ›ã€‚

#### æ ¸å¿ƒè®¾è®¡åŸåˆ™

1. **éœ€æ±‚é©±åŠ¨åˆ›å»º**: ä»…åœ¨çœŸå®éœ€æ±‚å‡ºç°æ—¶åˆ›å»ºæ–°å·¥å…·ï¼Œé¿å…å†—ä½™
2. **è‡ªä¸»ä»£ç ç”Ÿæˆ**: åŸºäºå¼€æºèµ„æºå’Œæœ€ä½³å®è·µè‡ªåŠ¨ç”ŸæˆMCP Serverä»£ç 
3. **ç¯å¢ƒè‡ªåŠ¨ç®¡ç†**: è‡ªåŠ¨è§£æä¾èµ–ã€æ„å»ºç¯å¢ƒã€æµ‹è¯•éªŒè¯
4. **çŸ¥è¯†ç§¯ç´¯å¤ç”¨**: æˆåŠŸåˆ›å»ºçš„MCPä½œä¸ºå¯é‡ç”¨èµ„äº§ï¼Œä¿ƒè¿›é›†ä½“æ™ºèƒ½è¿›åŒ–
5. **æ•…éšœè‡ªæ„ˆæœºåˆ¶**: åˆ›å»ºå¤±è´¥æ—¶è‡ªåŠ¨å°è¯•æ›¿ä»£æ–¹æ¡ˆï¼Œä»é”™è¯¯ä¸­å­¦ä¹ 

#### ä¸ç°æœ‰ç³»ç»Ÿçš„ååŒ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                æ™ºèƒ½å·¥å…·å‘ç°æœåŠ¡                               â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚    â”‚  æŸ¥è¯¢åˆ†æ       â”‚    â”‚  å·¥å…·åŒ…é€‰æ‹©                  â”‚    â”‚
â”‚    â”‚  Agentæ¨ç†      â”‚    â”‚  Agentæ¨ç†                  â”‚    â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                     â”‚                        â”‚
â”‚                          âŒ æ— åˆé€‚å·¥å…·å‘ç°                   â”‚
â”‚                                     â–¼                        â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚    â”‚        ğŸ› ï¸ åŠ¨æ€MCP Serverè‡ªåŠ¨æ„å»ºæ¨¡å—                â”‚    â”‚
â”‚    â”‚                                                     â”‚    â”‚
â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚    â”‚
â”‚    â”‚  â”‚ MCPéœ€æ±‚åˆ†æ â”‚ â”‚ ä»£ç ç”Ÿæˆå¼•æ“â”‚ â”‚ ç¯å¢ƒç®¡ç†å™¨  â”‚   â”‚    â”‚
â”‚    â”‚  â”‚   Agent     â”‚ â”‚             â”‚ â”‚             â”‚   â”‚    â”‚
â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚    â”‚
â”‚    â”‚                                                     â”‚    â”‚
â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚    â”‚
â”‚    â”‚  â”‚ ç½‘ç»œèµ„æºæœç´¢â”‚ â”‚ æµ‹è¯•éªŒè¯å™¨  â”‚ â”‚ MCPä»“åº“     â”‚   â”‚    â”‚
â”‚    â”‚  â”‚   Agent     â”‚ â”‚             â”‚ â”‚             â”‚   â”‚    â”‚
â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚    â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                     â”‚                        â”‚
â”‚                          âœ… æ–°MCP Serveråˆ›å»ºæˆåŠŸ             â”‚
â”‚                                     â–¼                        â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚    â”‚             å·¥å…·æ³¨å†Œä¸­å¿ƒ                            â”‚    â”‚
â”‚    â”‚         è‡ªåŠ¨æ³¨å†Œæ–°å»ºçš„MCP Server                    â”‚    â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 8.5.2 ä¸‰é˜¶æ®µCodeReActè‡ªè¿›åŒ–å¾ªç¯

åŸºäºAlitaè®ºæ–‡çš„CodeReActå¾ªç¯ç†å¿µï¼ŒMCP Serveræ„å»ºéµå¾ª**éœ€æ±‚åˆ†æ â†’ èµ„æºå‘ç° â†’ ä»£ç ç”Ÿæˆ â†’ æµ‹è¯•éªŒè¯ â†’ çŸ¥è¯†å°è£…**çš„è¿­ä»£æµç¨‹ï¼š

#### ç¬¬ä¸€é˜¶æ®µï¼šæ™ºèƒ½éœ€æ±‚åˆ†æä¸å·®è·è¯†åˆ«

**MCPéœ€æ±‚åˆ†æAgent** æ·±åº¦ç†è§£ç”¨æˆ·çœŸå®éœ€æ±‚ï¼Œè¯†åˆ«ç°æœ‰å·¥å…·ä½“ç³»çš„èƒ½åŠ›ç¼ºå£ï¼š

```python
class MCPRequirementAnalyzer:
    """åŸºäºAgentæ¨ç†çš„MCPéœ€æ±‚åˆ†æå™¨"""
    
    async def analyze_capability_gap(self, user_query: str, 
                                   existing_tools: List[ToolInfo],
                                   failed_scenarios: List[Dict]) -> MCPRequirementSpec:
        """åˆ†æèƒ½åŠ›ç¼ºå£ï¼Œç”ŸæˆMCPéœ€æ±‚è§„æ ¼"""
        
        analysis_prompt = f"""
ä½ æ˜¯ä¸€ä¸ªæ™ºèƒ½å·¥å…·éœ€æ±‚åˆ†æä¸“å®¶ã€‚ç”¨æˆ·çš„éœ€æ±‚æ— æ³•è¢«ç°æœ‰å·¥å…·æ»¡è¶³ï¼Œéœ€è¦åˆ›å»ºæ–°çš„MCP Serverã€‚

ç”¨æˆ·åŸå§‹éœ€æ±‚ï¼š{user_query}

ç°æœ‰å·¥å…·èƒ½åŠ›åˆ†æï¼š
{self._format_existing_tools(existing_tools)}

å¤±è´¥çš„å°è¯•è®°å½•ï¼š
{self._format_failed_scenarios(failed_scenarios)}

è¯·è¿›è¡Œæ·±åº¦éœ€æ±‚åˆ†æï¼š

1. **èƒ½åŠ›ç¼ºå£è¯†åˆ«**ï¼š
   - å…·ä½“ç¼ºå¤±ä»€ä¹ˆæ ¸å¿ƒåŠŸèƒ½ï¼Ÿ
   - ä¸ºä»€ä¹ˆç°æœ‰å·¥å…·æ— æ³•èƒœä»»ï¼Ÿ
   - éœ€è¦ä»€ä¹ˆæ ·çš„æ–°èƒ½åŠ›ç»„åˆï¼Ÿ

2. **MCPæŠ€æœ¯éœ€æ±‚**ï¼š
   - éœ€è¦ä»€ä¹ˆç¼–ç¨‹è¯­è¨€å’Œæ¡†æ¶ï¼Ÿ
   - æœ‰ä»€ä¹ˆç‰¹æ®Šçš„ä¾èµ–æˆ–ç¯å¢ƒè¦æ±‚ï¼Ÿ
   - é¢„æœŸçš„è¾“å…¥è¾“å‡ºæ ¼å¼æ˜¯ä»€ä¹ˆï¼Ÿ

3. **åŠŸèƒ½è§„æ ¼å®šä¹‰**ï¼š
   - æ ¸å¿ƒåŠŸèƒ½æ¨¡å—æœ‰å“ªäº›ï¼Ÿ
   - æ¯ä¸ªåŠŸèƒ½çš„å…·ä½“å®ç°é€»è¾‘ï¼Ÿ
   - é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶ï¼Ÿ

4. **å¼€æºèµ„æºçº¿ç´¢**ï¼š
   - å¯èƒ½çš„GitHubä»“åº“æˆ–é¡¹ç›®ï¼Ÿ
   - ç›¸å…³çš„æŠ€æœ¯æ–‡æ¡£æˆ–APIï¼Ÿ
   - ç±»ä¼¼åŠŸèƒ½çš„å®ç°å‚è€ƒï¼Ÿ

è¾“å‡ºæ ¼å¼ï¼š
CAPABILITY_GAP: [èƒ½åŠ›ç¼ºå£çš„ç²¾ç¡®æè¿°]
TECHNICAL_REQUIREMENTS: [æŠ€æœ¯æ ˆå’Œç¯å¢ƒéœ€æ±‚]
FUNCTIONAL_SPECS: [è¯¦ç»†åŠŸèƒ½è§„æ ¼]
RESOURCE_HINTS: [å¼€æºèµ„æºæœç´¢å…³é”®è¯]
PRIORITY_LEVEL: [ä¼˜å…ˆçº§: HIGH/MEDIUM/LOW]
COMPLEXITY_ESTIMATE: [å¤æ‚åº¦ä¼°è®¡: SIMPLE/MODERATE/COMPLEX]
        """
        
        response = await self.llm_client.generate(analysis_prompt)
        return self._parse_requirement_spec(response)
```

#### ç¬¬äºŒé˜¶æ®µï¼šç½‘ç»œèµ„æºæ™ºèƒ½æœç´¢ä¸ä»£ç ç”Ÿæˆ

**ç½‘ç»œèµ„æºæœç´¢Agent** è‡ªä¸»å‘ç°å’Œè¯„ä¼°å¼€æºèµ„æºï¼Œ**ä»£ç ç”Ÿæˆå¼•æ“** åŸºäºæœ€ä½³å®è·µåˆæˆMCP Serverï¼š
